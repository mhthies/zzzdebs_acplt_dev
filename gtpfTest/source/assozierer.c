/******************************************************************************
 *
 *   FILE
 *   ----
 *   assozierer.c
 *
 *   History
 *   -------
 *   2018-06-20   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/

#ifndef OV_COMPILE_LIBRARY_gtpfTest
#define OV_COMPILE_LIBRARY_gtpfTest
#endif

#include "gtpfTest.h"
#include "gtpf.h"
#include "libov/ov_macros.h"
#include "libov/ov_result.h"
#include "stdarg.h"
#include "ksbase.h"
#include "NoneTicketAuthenticator.h"

#include "unity.h"
#include "unity_fixture.h"

OV_INSTPTR_gtpfTest_assozierer gpinst;
OV_TIME *gpltc;

OV_RESULT ov_string_set_vecvalue_one(OV_STRING_VEC* vec, OV_UINT len, ...) {
	va_list args;
	va_start(args, len);
	OV_RESULT result = Ov_SetDynamicVectorLength(vec, len, STRING);
	for (OV_UINT i = 0; i < len; ++i) {
		result = ov_string_setvalue(&vec->value[i], va_arg(args, OV_STRING));
		if(Ov_Fail(result)) return result;
	}
	va_end(args);
	return 0;
}

OV_STRING ReadFile(OV_STRING filename) {
	char *buffer = NULL;
	int string_size, read_size;
	OV_STRING res = NULL;
	FILE *handler = fopen(filename, "r");

	if(handler) {
		// Seek the last byte of the file
		fseek(handler, 0, SEEK_END);
		// Offset from the first to the last byte, or in other words, filesize
		string_size = ftell(handler);
		// go back to the start of the file
		rewind(handler);

		// Allocate a string that can hold it all
		buffer = (char*) malloc(sizeof(char) * (string_size + 1));

		// Read it all in one operation
		read_size = fread(buffer, sizeof(char), string_size, handler);

		// fread doesn't set it so put a \0 in the last position
		// and buffer is now officially a string
		buffer[string_size] = '\0';

		if(string_size != read_size) {
			// Something went wrong, throw away the memory and set
			// the buffer to NULL
			free(buffer);
			buffer = NULL;
		}

		// Always remember to close the file.
		fclose(handler);
	}
	ov_string_setvalue(&res, buffer);
	free(buffer);

	return res;
}

void load_test_data(OV_STRING name) {
//	OV_RESULT res = 0;
	OV_SETVAR_PAR params = { 0 };
	OV_SETVAR_RES result = { 0 };

	OV_TICKET* pticket = NULL;

	OV_UINT number_of_variables = 3;
//TODO: check json value

	ov_memstack_lock();

//create NONE-ticket
	pticket = ksbase_NoneAuth->v_ticket.vtbl->createticket(NULL, OV_TT_NONE);

//#####################################################################
//process multiple variables at once
	OV_STRING dataPath = NULL;
	char* ahome = getenv("ACPLT_HOME");
	ov_string_print(&dataPath, "%s/dev/gtpfTest/test/%s", ahome, name);

	OV_SETVAR_ITEM items[3];
	OV_STRING uploadPath = "/data/CTree/Download";

	items[0].path_and_name = NULL;
	ov_string_print(&items[0].path_and_name, "%s.%s", uploadPath, "json"); /*	see comment below	*/
	items[0].var_current_props.value.vartype = KS_VT_STRING;
	items[0].var_current_props.value.valueunion.val_string = ReadFile(dataPath);

	items[1].path_and_name = NULL;
	ov_string_print(&items[1].path_and_name, "%s.%s", uploadPath, "path");
	items[1].var_current_props.value.vartype = KS_VT_STRING;
	items[1].var_current_props.value.valueunion.val_string = NULL;

	items[2].path_and_name = NULL;
	ov_string_print(&items[2].path_and_name, "%s.%s", uploadPath, "trigger");
	items[2].var_current_props.value.vartype = KS_VT_INT;
	items[2].var_current_props.value.valueunion.val_int = 1;

	params.items_val = items;
	params.items_len = number_of_variables;
	ov_ksserver_setvar(2, pticket, &params, &result);
	for (OV_UINT i = 0; i < number_of_variables; i++) {
		ov_string_setvalue(&params.items_val[i].path_and_name, NULL);
	}
	//TODO: free params.items_val[i].valuestr

	/*	delete Ticket	*/
	pticket->vtbl->deleteticket(pticket);

	/**
	 * Parse result from KS function
	 */

	if(Ov_Fail(result.result)) {
		//memory problem or NOACCESS
		ov_logfile_error("%s : NOACCESS or memory problem",
			ov_result_getresulttext(result.result));
		ov_memstack_unlock();
		return;
//		return result.result;
	}
	for (int i = 0; i < result.results_len; i++) {
//		OV_STRING resstring = NULL;
//		ov_string_setvalue(&resstring, ov_result_getresulttext(result.results_val[i]));
		if((result.results_val[i] != OV_ERR_OK)
				&& (result.results_val[i] != OV_ERR_NOACCESS)) return;
//			Download_log(pinst, OV_MT_WARNING, result.results_val[i],
//				"%s returns OV_RESULT: %i", params.items_val[i].path_and_name,
//				result.results_val[i]);
	}
//		fr = kshttp_print_result_array(&response->contentString, request.response_format, result.results_val, result.results_len, "");

	ov_memstack_unlock();
	return;
}

TEST_GROUP(assozierer);

TEST_SETUP(assozierer) {
	ov_memstack_lock();
	//This is run before EACH TEST
//	ov_string_setvalue(&gpinst->v_start, "PE004");
//	ov_string_set_vecvalue_one(&gpinst->v_recipe, 1, "PE005");
//	gpinst->v_EN = 0;
}

TEST_TEAR_DOWN(assozierer) {
	ov_memstack_unlock();
}

TEST(assozierer, assozierer_default) {
	load_test_data("default.json");
	ov_string_setvalue(&gpinst->v_Path, "/TechUnits/gtpfTest/case_default");
	gtpf_assozierer_typemethod(Ov_StaticPtrCast(fb_functionblock, gpinst), gpltc);

	TEST_ASSERT_EQUAL(gpinst->v_result, 0);
}

TEST(assozierer, assozierer_2neighbour) {
	load_test_data("2Neighbour.json");
	ov_string_setvalue(&gpinst->v_Path,
		"/TechUnits/gtpfTest/case_2neighbour_fix");
	gtpf_assozierer_typemethod(Ov_StaticPtrCast(fb_functionblock, gpinst), gpltc);

	TEST_ASSERT_EQUAL(gpinst->v_result, 0);
}

TEST(assozierer, assozierer_schieber) {
	load_test_data("schieber.json");
	ov_string_setvalue(&gpinst->v_Path, "/TechUnits/gtpfTest/case_schieber");
	gtpf_assozierer_typemethod(Ov_StaticPtrCast(fb_functionblock, gpinst), gpltc);

	TEST_ASSERT_EQUAL(gpinst->v_result, 0);
}
//
//TEST(assozierer, assozierer_badstart){
//	ov_string_setvalue(&gpinst->v_start, "PE0033");
//	gtpf_assozierer_typemethod(Ov_StaticPtrCast(fb_functionblock, gpinst), gpltc);
//	TEST_ASSERT_EQUAL(gpinst->v_result, 4);
//}
//	//test2 bad top
//TEST(assozierer, assozierer_badtopo){
////	ov_logfile_info("test: bad topo");
//	ov_string_setvalue(&gpinst->v_topologie, "PE03");
//	gtpf_assozierer_typemethod(Ov_StaticPtrCast(fb_functionblock, gpinst), gpltc);
//	TEST_ASSERT_EQUAL(gpinst->v_result, 4);
//}
//
////test3 start==end
//TEST(assozierer, assozierer_start_same_end){
////	ov_logfile_info("test: start==end");
//	ov_string_set_vecvalue_one(&gpinst->v_recipe, 1, "PE004");
//	gtpf_assozierer_typemethod(Ov_StaticPtrCast(fb_functionblock, gpinst), gpltc);
//	TEST_ASSERT_EQUAL(gpinst->v_result,0);
//	OV_UINT pathDirLen = 0;
//	TEST_ASSERT_EQUAL(gpinst->v_pathDir.veclen, pathDirLen);
//
//	OV_UINT pathNodeLen = 0;
//	TEST_ASSERT_EQUAL(gpinst->v_pathNode.veclen, pathNodeLen);
//
//	OV_UINT paramLen = 0;
//	TEST_ASSERT_EQUAL(gpinst->v_parameter.veclen, paramLen);
//}
//
//TEST(assozierer, assozierer_heat_turn){
//	//test4
//	ov_logfile_info("test: heat & turn");
//	ov_string_set_vecvalue_one(&gpinst->v_recipe, 3, "PE009 Heat", "PE025 Turn",
//		"PE033");
//	gtpf_assozierer_typemethod(Ov_StaticPtrCast(fb_functionblock, gpinst), gpltc);
//	TEST_ASSERT_EQUAL(gpinst->v_result, 0);
//
//	OV_UINT pathDirLen = 16;
//	OV_STRING pathDirValue[] = { "right", "right", "right", "right",
//			"heat", "left", "left", "left", "down", "right", "right", "right", "turn",
//			"right", "right", "right" };
//	TEST_ASSERT_EQUAL(gpinst->v_pathDir.veclen, pathDirLen);
//	TEST_ASSERT_EQUAL_STRING_ARRAY(pathDirValue, gpinst->v_pathDir.value,
//		pathDirLen);
//
//	OV_UINT pathNodeLen = 16;
//	OV_STRING pathNodeValue[] = { "PE034", "PE005", "PE008", "PE009",
//			"PE009", "PE008", "PE005", "PE034", "PE034", "PE031", "PE030", "PE025",
//			"PE025", "PE028", "PE027", "PE033" };
//	TEST_ASSERT_EQUAL(gpinst->v_pathNode.veclen, pathNodeLen);
//	TEST_ASSERT_EQUAL_STRING_ARRAY(pathNodeValue, gpinst->v_pathNode.value,
//		pathNodeLen);
//
//	OV_UINT paramLen = 16;
//	OV_STRING paramValue[] = {NULL, NULL, NULL, NULL, "150", NULL, NULL, NULL,
//			NULL, NULL, NULL, NULL, "180", NULL, NULL, NULL };
//	TEST_ASSERT_EQUAL(gpinst->v_parameter.veclen, paramLen);
//	TEST_ASSERT_EQUAL_STRING_ARRAY(paramValue, gpinst->v_parameter.value, paramLen);
//}
//
//TEST(assozierer, assozierer_heat2_turn2){
//	//test5
////	ov_logfile_info("test: (heat&heat) & (turn&turn)");
//	ov_string_set_vecvalue_one(&gpinst->v_recipe, 3, "PE009 Heat", "PE009 Heat",
//		"PE025 Turn", "PE025 Turn");
//	gtpf_assozierer_typemethod(Ov_StaticPtrCast(fb_functionblock, gpinst), gpltc);
//
//	OV_UINT pathDirLen = 13;
//	OV_STRING pathDirValue[] = { "right", "right", "right", "right",
//			"heat", "left", "left", "left", "down", "right", "right", "right",
//			"turn" };
//	TEST_ASSERT_EQUAL(gpinst->v_pathDir.veclen, pathDirLen);
//	TEST_ASSERT_EQUAL_STRING_ARRAY(pathDirValue, gpinst->v_pathDir.value,
//		pathDirLen);
//
//	OV_UINT pathNodeLen = 13;
//	OV_STRING pathNodeValue[] = { "PE034", "PE005", "PE008", "PE009",
//			"PE009", "PE008", "PE005", "PE034", "PE034", "PE031", "PE030", "PE025",
//			"PE025" };
//	TEST_ASSERT_EQUAL(gpinst->v_pathNode.veclen, pathNodeLen);
//	TEST_ASSERT_EQUAL_STRING_ARRAY(pathNodeValue, gpinst->v_pathNode.value,
//		pathNodeLen);
//
//	OV_UINT paramLen = 13;
//	OV_STRING paramValue[] = {NULL, NULL, NULL, NULL, "150", NULL, NULL, NULL,
//			NULL, NULL, NULL, NULL, "180" };
//	TEST_ASSERT_EQUAL(gpinst->v_parameter.veclen, paramLen);
//	TEST_ASSERT_EQUAL_STRING_ARRAY(paramValue, gpinst->v_parameter.value, paramLen);
//}
//
TEST_GROUP_RUNNER(assozierer) {
	RUN_TEST_CASE(assozierer, assozierer_default);
//	RUN_TEST_CASE(assozierer, assozierer_2neighbour);
//	RUN_TEST_CASE(assozierer, assozierer_schieber);
//  RUN_TEST_CASE(assozierer, assozierer_badstart);
//  RUN_TEST_CASE(assozierer, assozierer_badtopo);
//  RUN_TEST_CASE(assozierer, assozierer_start_same_end);
//  RUN_TEST_CASE(assozierer, assozierer_heat_turn);
//  RUN_TEST_CASE(assozierer, assozierer_heat2_turn2);
//  RUN_TEST_CASE(assozierer, AnotherIgnoredTest);
//  RUN_TEST_CASE(assozierer, ThisFunctionHasNotBeenTested_NeedsToBeImplemented);
}

static void RunAllTests(void) {
	RUN_TEST_GROUP(assozierer);
}

OV_DLLFNCEXPORT void gtpfTest_assozierer_typemethod(

OV_INSTPTR_fb_functionblock pfb,

OV_TIME *pltc) {
	/*
	 *   local variables
	 */
	gpinst = Ov_StaticPtrCast(gtpfTest_assozierer, pfb);
	gpltc = pltc;

	const OV_STRING argv[] = { "assozierer", "-v" };
	UnityMain(2, argv, RunAllTests);
	return;
}

