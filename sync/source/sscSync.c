
/******************************************************************************
*
*   FILE
*   ----
*   sync.c
*
*   History
*   -------
*   2018-08-02   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_sync
#define OV_COMPILE_LIBRARY_sync
#endif


#include "sync.h"
#include "libov/ov_macros.h"
#include "libov/ov_result.h"
#include "libov/ov_path.h"
#include "ssc.h"

#include "CException.h"

#include "ksbase_helper.h"

#include "object_helper.h"

void syncCallback(const OV_INSTPTR_ov_domain this,
		const OV_INSTPTR_ov_domain that);

OV_DLLFNCEXPORT OV_RESULT sync_sscSync_constructor(OV_INSTPTR_ov_object pobj) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_sync_sscSync pinst = Ov_StaticPtrCast(sync_sscSync, pobj);
	OV_RESULT result;

	/* do what the base class does first */
	result = fb_functionblock_constructor(pobj);
	if(Ov_Fail(result)) return result;

	/* do what */
	pinst->p_setVar.p_apiSet.v_Callback.callbackFunction = &syncCallback;
	pinst->p_setVar.p_apiSet.v_Callback.instanceCalled = Ov_StaticPtrCast(
		ov_domain, pobj);

//	OV_INSTPTR_ksapi_KSApiCommon

	return OV_ERR_OK;
}

//void callBack(OV_INSTPTR)

void sync_sscSync_setProctime(OV_INSTPTR_sync_sscSync pinst, OV_TIME *time) {
	OV_RESULT result = OV_ERR_OK;
	OV_INSTPTR_ssc_SequentialStateChart pssc = NULL;
	Ov_ForEachChild(sync_sscSyncAssoc, pinst, pssc)
	{
		pssc->v_proctime = *time;
	}
	return;
}

OV_RESULT sync_sscSync_makeProctimeRoom(OV_INSTPTR_sync_sscSync pinst,
		OV_TIME_SPAN *span) {
	OV_RESULT result = OV_ERR_OK;
	OV_TIME incTime = { 0 };
	OV_INSTPTR_ssc_SequentialStateChart pssc = NULL;
	OV_TIME_SPAN diff = { 0 };
	OV_DOUBLE diffDouble = 0;

	OV_DOUBLE spanDouble;
	Ov_TimeSpanToDouble(*span, spanDouble);

	OV_TIME now;
	ov_time_gettime(&now);
	//todo: make room

	OV_TIME newProc;
	ov_time_add(&newProc, &now, span);

	Ov_ForEachChild(sync_sscSyncAssoc, pinst, pssc)
	{
		ov_time_diff(&diff, &pssc->v_proctime, &newProc);
		if(diff.secs < 0 || diff.usecs < 0) {
			pssc->v_proctime = newProc;
		}
	}
	for (OV_UINT i = 0; i < 10; i++) {
		ov_time_gettime(&now);
		ov_time_diff(&diff, &newProc, &now);
		Ov_TimeSpanToDouble(diff, diffDouble);
		if(spanDouble < diffDouble) {

		}
	}
	return result;
}

OV_SINGLE sync_sscSync_ping(OV_STRING server) {
	OV_SINGLE val = 0;
	return val;
}

void sync_sscSync_add(OV_INSTPTR_sync_sscSync pinst,
		OV_INSTPTR_ssc_SequentialStateChart pobj) {
	OV_INSTPTR_fbcomlib_setVar pSetVar = &pinst->p_setVar;
	OV_RESULT result = OV_ERR_OK;
	OV_INSTPTR_sync_sscVar var = NULL;
	OV_STRING serverPath = pSetVar->v_path;

	result = Ov_CreateObject(sync_sscVar, var, &pinst->p_setVar,
		pobj->v_identifier); //todo: samename?
	if(result) {
		ov_logfile_error("%s", ov_result_getresulttext(result));
		Throw(OV_ERR_GENERIC);
	}
	/* setting once */
//		OV_ANY tmp = { 0, 0, 0 }
//		tmp.value.vartype = OV_VT_STRING;
//		ov_string_setvalue(&tmp.value.valueunion.val_string, pobj->v_activeStep);
//		ov_variable_setanyvalue(var->v_value, )
	OV_STRING varPath = ov_path_getcanonicalpath(var, 2);

	OV_INSTPTR_fb_connection pconn = NULL;
	OV_INSTPTR_ov_domain pconndom = ov_path_getobjectpointer("/Cons", 2);
	OV_STRING pconnid = NULL;
	ov_string_print(&pconnid, "sync_%s_%s", pinst->v_identifier,
		pobj->v_identifier);
	Ov_CreateObject(fb_connection, pconn, pconndom, pconnid);

	/* setting var */
	OV_STRING objPath = ov_path_getcanonicalpath(pobj, 2);
	OV_STRING targetPath = NULL;
	ov_string_print(&targetPath, "%s%s", serverPath,
		&objPath[ov_string_getlength(pinst->v_path)]);
	ov_string_print(&var->v_path, "%s.initStateName", targetPath);

	/* setting conn */
	Ov_Link(fb_inputconnections, var, pconn);
	Ov_Link(fb_outputconnections, pobj, pconn);
	ov_string_setvalue(&pconn->v_targetport, "port");
	ov_string_setvalue(&pconn->v_sourceport, "activeStep");
	pconn->v_sourcetrig = 1;
	pconn->v_on = 1;

	fb_connection_trigger(pconn);

	/* connect to setvar */
	Ov_Link(fbcomlib_PkgVar, pSetVar, var);
}

void sync_sscSync_remove(OV_INSTPTR_sync_sscSync pinst,
		OV_INSTPTR_ssc_SequentialStateChart pobj) {
	OV_INSTPTR_sync_sscVar pvar = NULL;
	OV_INSTPTR_fb_connection pconn = NULL;
//	pconn = Ov_GetChild(fb_inputconnections, pobj);
	pvar = Ov_GetParent(fb_outputconnections, pconn);

	Ov_DeleteObject(pvar);
	Ov_DeleteObject(pconn);
	Ov_DeleteObject(pobj);
	return;
}

void sync_sscSync_createConnections(OV_INSTPTR_sync_sscSync pinst) {
	OV_INSTPTR_ov_object proot = ov_path_getobjectpointer(pinst->v_path, 2);
	if(!proot) Throw(OV_ERR_BADPARAM);

	OV_INSTPTR_ov_class pssc = ov_class_search("ssc/SequentialStateChart");
	if(!pssc)
	Throw(OV_ERR_GENERIC);

	OV_INSTPTR_ssc_SequentialStateChart pobj = NULL;
	Ov_ForEachChildEx(ov_instantiation, pssc, pobj, ssc_SequentialStateChart)
	{
		/* checking if right one */
		if(!object_isDescendant(proot, pobj)) continue;

		/* add it to sync */
		sync_sscSync_add(pinst, pobj);
	}
	return;
}

void sync_sscSync_change();

OV_RESULT sync_sscSync_send(OV_INSTPTR_sync_sscSync pinst) {
	OV_RESULT result = OV_ERR_OK;
	OV_INSTPTR_fbcomlib_setVar pSetVar = &pinst->p_setVar;
	OV_TIME time;
	ov_time_gettime(&time);
	fbcomlib_setVar_typemethod(Ov_StaticPtrCast(fb_functionblock, pSetVar),
		&time);

	/* setting changed */
	OV_INSTPTR_sync_sscVar pvar = NULL;
	Ov_ForEachChildEx(fbcomlib_PkgVar, pSetVar, pvar, sync_sscVar)
	{
		pvar->v_changed = 0;
	}
	return result;
}


OV_RESULT sync_sscSync_execute(OV_INSTPTR_sync_sscSync pinst) {
	OV_RESULT result = OV_ERR_OK;
	OV_INSTPTR_fbcomlib_setVar pSetVar = &pinst->p_setVar;
	OV_STRING serverHost = NULL;
	OV_STRING serverPort = NULL;
	OV_STRING serverName = NULL;
	OV_STRING serverPath = NULL;
	result = ks_splitOneStringPath(pinst->v_targetKS, &serverHost, &serverPort,
		&serverName,
		NULL,
		&serverPath);
	ov_string_setvalue(&pinst->p_setVar.v_host, serverHost);
	ov_string_setvalue(&pinst->p_setVar.v_server, serverName);
	/* using v_path as temp storage */
	ov_string_setvalue(&pinst->p_setVar.v_path, serverPath);

	OV_INSTPTR_ov_object proot = ov_path_getobjectpointer(pinst->v_path, 2);
	if(!proot) Throw(OV_ERR_BADPARAM);

	OV_STRING path = NULL;

	OV_INSTPTR_ssc_SequentialStateChart pobj = NULL;

	/*1.*/
	sync_sscSync_createConnections(pinst);

	/* sending var */
	sync_sscSync_send(pinst);

}

void syncCallback(const OV_INSTPTR_ov_domain this,
		const OV_INSTPTR_ov_domain that) {
	OV_INSTPTR_sync_sscSync thisGV = Ov_StaticPtrCast(sync_sscSync, this);
	OV_INSTPTR_ksbase_ClientBase pClient = Ov_StaticPtrCast(ksbase_ClientBase,
		that);
	OV_INSTPTR_ksapi_Variable pCurrVar = NULL;
	OV_VTBLPTR_ksbase_ClientBase pVtblClient = NULL;
	OV_UINT itemsLength;
	OV_RESULT* itemsResults = NULL;
	OV_RESULT result;

//	if(!this || !that) {
//		KS_logfile_error(("callback issued with NULL pointers. aborting."));
//		return;
//	}
//
//	Ov_GetVTablePtr(ksbase_ClientBase, pVtblClient, pClient);
//
//	if(!pVtblClient) {
//		KS_logfile_error(
//			("%s callback: could not determine Vtable of Client %s. aborting", this->v_identifier, that->v_identifier));
//		thisSV->v_status = KSAPI_COMMON_INTERNALERROR;
//		thisSV->v_result = OV_ERR_BADOBJTYPE;
//		return;
//	}
//	ov_memstack_lock();
//	result = pVtblClient->m_processSetVar(pClient, NULL,
//		(OV_RESULT*) &(thisSV->v_result), &itemsLength, &itemsResults);
//	if(Ov_Fail(result)) {
//		thisSV->v_status = KSAPI_COMMON_INTERNALERROR;
//		thisSV->v_result = result;
//		ov_memstack_unlock();
//		return;
//	}
//
//	if(Ov_Fail(thisSV->v_result)) {
//		thisSV->v_status = KSAPI_COMMON_EXTERNALERROR;
//			ov_memstack_unlock();
//			return;
//		}
//
//	thisSV->v_varRes = itemsResults[0];
//	thisSV->v_status = KSAPI_COMMON_REQUESTCOMPLETED;
//	/*	iterate over variable objects in containment and linked ones and fill in the results	*/
//	Ov_ForEachChildEx(ov_containment, thisSV, pCurrVar, ksapi_Variable)
//	{
//		if(pCurrVar->v_order) {
//			if(pCurrVar->v_order <= itemsLength) {
//				pCurrVar->v_varRes = itemsResults[pCurrVar->v_order - 1];
//				pCurrVar->v_order = 0; /*	reset order	*/
//			} else {
//				pCurrVar->v_varRes = OV_ERR_BADPLACEMENT;
//				}
//			}
//		}
//
//	Ov_ForEachChild(ksapi_operationToVariable, thisSV, pCurrVar)
//	{
//		if(pCurrVar->v_order) {
//			if(pCurrVar->v_order <= itemsLength)
//
//			{
//				pCurrVar->v_varRes = itemsResults[pCurrVar->v_order - 1];
//				pCurrVar->v_order = 0; /*	reset order	*/
//			} else {
//				pCurrVar->v_varRes = OV_ERR_BADPLACEMENT;
//				}
//		}
//	}
//
//	ov_memstack_unlock();
//	OV_UINT restssc;
//	if(restssc)
//		sync_sscSync_execute(&(thisGV->p_setVar));
//	return;
}


OV_DLLFNCEXPORT void sync_sscSync_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    /*
    *   local variables
    */
	OV_INSTPTR_sync_sscSync pinst = Ov_StaticPtrCast(sync_sscSync, pfb);
	OV_RESULT result = OV_ERR_OK;
	CEXCEPTION_T err;
	Try
			{
				result = sync_sscSync_execute(pinst);
				switch (result) {
					case OV_ERR_OK:
						ov_logfile_info("sscSync: done");
						pinst->v_result = result;
						break;
					default:
						ov_logfile_error("sscSync: failed error: %s",
					ov_result_getresulttext(result));
				pinst->v_result = 1;
		}
	}
	Catch(err)
	{
		switch (err) {
			case OV_ERR_BADPARAM:
				ov_logfile_error("sscSync cexp: bad param");
				pinst->v_result = err;
				break;
			default:
				ov_logfile_error("sscSync cexp: failed error: %s",
					ov_result_getresulttext(err));
				pinst->v_result = 1;
		}
	}
    return;
}

