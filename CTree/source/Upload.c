/******************************************************************************
 *
 *   FILE
 *   ----
 *   Upload.c
 *
 *   History
 *   -------
 *   2018-02-23   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/

#define OV_DEBUG

#ifndef OV_COMPILE_LIBRARY_CTree
#define OV_COMPILE_LIBRARY_CTree
#endif

#include "libov/ov_ov.h"
#include "CTree.h"
#include "libov/ov_macros.h"
#include "libov/ov_string.h"
#include "libov/ov_class.h"
#include "libov/ov_library.h"
#include "libov/ov_path.h"
#include "libov/ov_association.h"

#include "ksbase.h"
#include "NoneTicketAuthenticator.h"

#include "cJSON.h"

#include "libov/ov_debug.h"

#include <stdarg.h>
#include <string.h>
#include <stdio.h>

#define VERSION_FOR_CTREE 	2
#define VARIABLE_FORMAT_SIZE	3


typedef struct {
	OV_INSTPTR_CTree_Upload pinst;
	OV_INSTPTR_ov_object proot;
	OV_STRING root_path;
	OV_STRING current_path;
} CtreeUpload;

OV_RESULT CtreeUplaod_init(CtreeUpload* pupload, OV_INSTPTR_CTree_Upload pinst) {
	OV_RESULT res = OV_ERR_OK;
	pupload->pinst = pinst;
	pupload->root_path = "";
	ov_string_append(&pupload->root_path, pinst->v_root);
	pupload->proot = ov_path_getobjectpointer(pinst->v_root, VERSION_FOR_CTREE);

	//TODO: find out from object
//	ov_string_setvalue(&pupload->pinst->p_apiSet.v_serverHost, "localhost");
//	ov_string_setvalue(&pupload->pinst->p_apiSet.v_serverName, "MANAGER");

	return res;
}

OV_RESULT print_log(CtreeUpload* pupload,
		void (*ov_logfile)(const OV_STRING, ...), const OV_STRING format, ...) {
	OV_RESULT res = OV_ERR_OK;
	va_list args;
	(*ov_logfile)(format, args);

	ov_string_print(&pupload->pinst->v_log, format, args);
	if (ov_logfile == ov_logfile_error)
		ov_string_print(&pupload->pinst->v_errorLog, format, args);
	return res;
}

OV_RESULT print_log_exit(CtreeUpload* pupload, OV_RESULT result,
		void (*ov_logfile)(const OV_STRING, ...), const OV_STRING format, ...) {
	va_list args;
	pupload->pinst->v_return = result;
	return print_log(pupload, ov_logfile, format, args);
}

OV_ANY get_value_from_str(cJSON* jsvar) {
	OV_ANY value;
	value.state = OV_ST_GOOD;
	CTree_helper_strToOVType(&value.value.vartype,
			cJSON_GetArrayItem(jsvar, 2)->valuestring);
	CTree_helper_strToValue(&value.value,
			cJSON_GetArrayItem(jsvar, 1)->valuestring);
//	OV_STRING typestr = "";
//	CTree_helper_ovtypeToStr(&typestr, &value.value.vartype);
//	OV_STRING valuestr = "";
//	CTree_helper_valueToStr(&valuestr, &value.value);
//	ov_logfile_debug("%s:%s has type %i : %s with value %s", jsvar->string, cJSON_GetArrayItem(jsvar, 2)->valuestring, value.value.vartype, typestr, valuestr);
	return value;
}


OV_RESULT set_variable_values(CtreeUpload* pupload, cJSON* jsvariables,
		OV_INSTPTR_ov_object pobj) {
	/*
	 *	parameter and result objects
	 */
//	OV_INSTPTR_ksapi_setVar papiSet = &(pupload->pinst->p_apiSet);

	OV_RESULT res = OV_ERR_OK;

	cJSON* jsvariable = NULL;
	OV_UINT number_of_variables = cJSON_GetArraySize(jsvariables);
	OV_STRING objpathwithpunct = NULL;

	OV_SETVAR_PAR params;
	OV_SETVAR_RES result;
	OV_SETVAR_ITEM *addrp = NULL;

	OV_TICKET* pticket = NULL;

	//object path
	ov_memstack_lock();
	ov_string_setvalue(&objpathwithpunct,
			ov_path_getcanonicalpath(pobj, VERSION_FOR_CTREE));
	ov_string_append(&objpathwithpunct, ".");
	ov_memstack_unlock();

	//TODO: check json value

	ov_memstack_lock();
	addrp = (OV_SETVAR_ITEM*) ov_memstack_alloc(
			number_of_variables * sizeof(OV_SETVAR_ITEM));

	if (!addrp) {
		ov_memstack_unlock();
		res = OV_ERR_TARGETGENERIC;
		print_log_exit(pupload, res, ov_logfile_error, "%s",
				": internal memory problem");
		return res;
	}

	params.items_val = addrp;
	params.items_len = number_of_variables;

	//create NONE-ticket
	pticket = ksbase_NoneAuth->v_ticket.vtbl->createticket(NULL, OV_TT_NONE);

	//#####################################################################
	//process multiple variables at once
	cJSON_ArrayForEach(jsvariable, jsvariables)
	{
		addrp->var_current_props.value = get_value_from_str(jsvariable).value;
		//TODO:check for vartype and value

		OV_STRING strlist[] = {objpathwithpunct, jsvariable->string};
		OV_STRING_VEC variable_path = {.veclen=2, .value=strlist};
		addrp->path_and_name = CTree_helper_strlistcat(&variable_path);

		//add one size of a pointer
		addrp++;
	}

	ov_ksserver_setvar(2, pticket, &params, &result);

	/*	delete Ticket	*/
	pticket->vtbl->deleteticket(pticket);

	/**
	 * Parse result from KS function
	 */

	if (Ov_Fail(result.result)) {
		//memory problem or NOACCESS
//			kshttp_print_result_array(&response->contentString, request.response_format, &result.result, 1, ": NOACCESS or memory problem");
		ov_memstack_unlock();
		return result.result;
	}
	for (int i = 0; i < result.results_len; i++) {
//		OV_STRING resstring = NULL;
//		ov_string_setvalue(&resstring, ov_result_getresulttext(result.results_val[i]));
		ov_logfile_debug("%i",  result.results_val[i]);
	}
//		fr = kshttp_print_result_array(&response->contentString, request.response_format, result.results_val, result.results_len, "");

	ov_memstack_unlock();
	return res;
}



OV_RESULT upload_tree(CtreeUpload* pupload, cJSON* jsparent,
		OV_INSTPTR_ov_domain pparent) {

	OV_RESULT res = OV_ERR_OK;

	OV_INSTPTR_ov_class pclass = NULL;
	OV_INSTPTR_ov_object pobj = NULL;
	OV_INSTPTR_ov_object pclassobj = NULL;
	OV_STRING identifier = NULL;

	cJSON* jschild = NULL;
	cJSON* jscurrent = NULL;
	OV_STRING parentpath = NULL;

	//TODO: find more elegant solution to get path
	ov_memstack_lock();
	ov_string_setvalue(&parentpath,
			ov_path_getcanonicalpath(Ov_PtrUpCast(ov_object, pparent),
			VERSION_FOR_CTREE));
	ov_memstack_unlock();

	cJSON_ArrayForEach(jschild, jsparent)
	{
//		1. Getting identifier
		ov_string_setvalue(&identifier, jschild->string);
		if (!identifier) {
			return OV_ERR_BADPARAM;
		}

//		2. Getting class pointer
		jscurrent = cJSON_GetObjectItemCaseSensitive(jschild, "factory");
		OV_STRING factory = cJSON_GetStringValue(jscurrent);
		pclassobj = ov_path_getobjectpointer(factory, VERSION_FOR_CTREE);
		if (pclassobj == NULL) {
			ov_logfile_error("There is no class with path %s", factory);
		}
		pclass = Ov_StaticPtrCast(ov_class, pclassobj);
		if (pclass == NULL) {
			ov_logfile_error("There is no class with path %s", factory);
		}

//		3. Creating Object
		res =
				ov_class_createobject(pclass,
						((OV_INSTPTR_ov_domain) ((pparent)
								+ (0
										* ((pparent)->__classinfo.is_of_class_ov_domain)))),
						identifier, ((OV_PLACEMENT_HINT) 0), ((void *) 0),
						((void *) 0), ((void *) 0),
						((OV_INSTPTR_ov_object*) &(pobj)));
		if (Ov_Fail(res)) {
			if (res == OV_ERR_ALREADYEXISTS) {
				//TODO: check if it is from same class
				OV_STRING strvalue[] = { parentpath, "/", identifier };
				OV_STRING_VEC strvector = { .veclen = 3, .value = strvalue };
				pobj = ov_path_getobjectpointer(CTree_helper_strlistcat(&strvector),
				VERSION_FOR_CTREE);
				ov_logfile_warning("%s already exists", identifier);
			} else {
				ov_logfile_error("Could not create %s in %s", identifier,
						parentpath);
				return res;
			}
		} else {
			ov_logfile_info("created %s/%s", parentpath, identifier);
		}

		//	1. Set Variables
		cJSON* jsvariables = cJSON_GetObjectItemCaseSensitive(jschild,
				"variables");

		set_variable_values(pupload, jsvariables, pobj);

		res = upload_tree(pupload, cJSON_GetObjectItem(jschild, "children"),
				Ov_StaticPtrCast(ov_domain, pobj));
		if (Ov_Fail(res)) {
			//TODO: give more info
			ov_logfile_error("Could not load tree. error at %s", parentpath);
			return res;
		}
	}
	return res;
}

OV_RESULT upload_libraries(CtreeUpload* pupload, const cJSON* jslibs) {
	cJSON* current = NULL;
	OV_INSTPTR_ov_library plib = NULL;
	OV_RESULT res = 0;

	cJSON_ArrayForEach(current, jslibs)
	{
		if (!cJSON_IsString(current)) {
			return OV_ERR_BADPARAM;
		}
		OV_STRING libname = cJSON_GetStringValue(current);
		plib = ov_library_search(libname);
		res = Ov_CreateObject(ov_library, plib, &(pdb->acplt), libname);

		//	2.3 check if loaded successfully?
		switch (res) {
		case OV_ERR_OK:
			print_log(pupload, ov_logfile_info, "Library %s loaded", libname);
			break;
		case OV_ERR_ALREADYEXISTS:
			print_log(pupload, ov_logfile_info, "Library %s exists", libname);
			break;
		default:
			print_log_exit(pupload, res, ov_logfile_error,
					"Could not load library %s", libname);
			return res;
		}
	}
	return res;
}

OV_RESULT link_objects(const cJSON* jslinks) {
	OV_RESULT res = OV_ERR_OK;
	cJSON* jschild = NULL;
	cJSON* current = NULL;
	OV_INSTPTR_ov_association passoc = NULL;
	OV_INSTPTR_ov_object pparent = NULL;
	OV_INSTPTR_ov_object pchild = NULL;

	if (jslinks == NULL)
		return OV_ERR_BADPARAM;

	cJSON_ArrayForEach(jschild, jslinks)
	{
		current = cJSON_GetObjectItem(jschild, "of_association");
		passoc =
				Ov_StaticPtrCast(ov_association,
						ov_path_getobjectpointer(cJSON_GetStringValue(current), VERSION_FOR_CTREE));

		cJSON* jsasparent = NULL;
		cJSON* jsasparents = cJSON_GetObjectItem(jschild, "parents");

		cJSON_ArrayForEach(jsasparent, jsasparents)
		{
			pparent = ov_path_getobjectpointer(cJSON_GetStringValue(jsasparent),
			VERSION_FOR_CTREE);
			if (pparent == NULL) {
				ov_logfile_error("%s does not exist",
						cJSON_GetStringValue(jsasparent));
				continue;
				//			return OV_ERR_BADPARAM;
			}

			cJSON* jsaschild = NULL;
			cJSON* jsaschildren = cJSON_GetObjectItem(jschild, "children");
			cJSON_ArrayForEach(jsaschild, jsaschildren)
			{
				OV_STRING path = cJSON_GetStringValue(jsaschild);
				pchild = ov_path_getobjectpointer(path, VERSION_FOR_CTREE);
				if (pchild == NULL) {
					ov_logfile_error("%s does not exist", path);
					continue;
					//			return OV_ERR_BADPARAM;
				}

				res = ov_association_link(passoc, pparent, pchild,
				OV_PMH_DEFAULT, NULL, OV_PMH_DEFAULT, NULL);
				if (Ov_OK(res))
					ov_logfile_info("%s linked with %s through %s",
							pparent->v_identifier, pchild->v_identifier,
							passoc->v_identifier);
				else {
					ov_logfile_error("%s can not be linked with %s through %s",
							pparent->v_identifier, pchild->v_identifier,
							passoc->v_identifier);
					res = OV_ERR_OK;
					//!!!
				}
			}
		}

	}
	return res;
}

OV_DLLFNCEXPORT void CTree_Upload_typemethod(OV_INSTPTR_fb_functionblock pfb,
		OV_TIME *pltc) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_CTree_Upload pinst = Ov_StaticPtrCast(CTree_Upload, pfb);

//    ov_string_setvalue(&pinst->v_json, "{\"Path\":\"/TechUnits\", \"Tree\":{\"A\":{\"factory\":\"/acplt/CTree/Upload\",\"variables\":{},\"children\":{\"AA\":{\"factory\":\"/acplt/CTree/Upload\",\"variables\":{},\"children\":{}}}}},\"Links\":{},\"Libraries\":[\"CTree\",\"ksapi\"]}");
	OV_RESULT res;
	CtreeUpload upload;		// = ov_memstack_alloc(sizeof(CtreeUpload));
	CtreeUplaod_init(&upload, pinst);

	//1. parse input
	cJSON * jsbase = NULL;
	cJSON * jslibs = NULL;
	cJSON * jslinks = NULL;
	cJSON * jstree = NULL;
	cJSON * jspath = NULL;
	cJSON * current = NULL;

	jsbase = cJSON_Parse(pinst->v_json);
	//1.1 check if file is ok
	if (jsbase == NULL) {
		const char *error_ptr = cJSON_GetErrorPtr();
		if (error_ptr != NULL) {
//			print_log(&upload, ov_logfile_error, "bad js file");
		}
		print_log_exit(&upload, OV_ERR_BADPARAM, ov_logfile_error,
				"Bad json file");
		return;
	}
	print_log(&upload, ov_logfile_info, "parsed successfully");

//   2. Load Libraries
//   2.1 jsbase contains libraries?
	jslibs = cJSON_GetObjectItem(jsbase, "Libraries");
	if (jslibs == NULL) {
		print_log(&upload, ov_logfile_info, "No libraries to load");
	}

//  2.2 load
	res = upload_libraries(&upload, jslibs);
//  2.3 successfully?
	if (Ov_Fail(res))
		if (res != OV_ERR_ALREADYEXISTS) {
			print_log_exit(&upload, res, ov_logfile_error,
					"Couldnt load dependent libraries");
			return;
		}

//	3. CreateObjects Iterativly
	jstree = cJSON_GetObjectItem(jsbase, "Tree");

	OV_STRING rootpath = NULL;
	ov_string_setvalue(&rootpath,
			cJSON_GetStringValue(cJSON_GetObjectItem(jsbase, "Path")));

	OV_INSTPTR_ov_object proot = ov_path_getobjectpointer(rootpath,
	VERSION_FOR_CTREE);
	upload_tree(&upload, jstree, Ov_StaticPtrCast(ov_domain, proot));

//	4. Link
	jslinks = cJSON_GetObjectItem(jsbase, "Links");
	link_objects(jslinks);

	// Free memory
	ov_string_setvalue(&pinst->v_json, "");
	cJSON_Delete(jsbase);
	return;
}

