/******************************************************************************
 *
 *   FILE
 *   ----
 *   Upload.c
 *
 *   History
 *   -------
 *   2018-02-23   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/

#define OV_DEBUG

#ifndef OV_COMPILE_LIBRARY_CTree
#define OV_COMPILE_LIBRARY_CTree
#endif

#include "libov/ov_ov.h"
#include "CTree.h"

#include "libov/ov_macros.h"
#include "libov/ov_string.h"
#include "libov/ov_class.h"
#include "libov/ov_library.h"
#include "libov/ov_path.h"
#include "libov/ov_association.h"
#include "libov/ov_result.h"

#include "ksbase.h"
#include "NoneTicketAuthenticator.h"

#include "cJSON.h"

#include "libov/ov_debug.h"

#include <stdarg.h>
#include <string.h>
#include <stdio.h>

#define VERSION_FOR_CTREE 	2
#define VARIABLE_FORMAT_SIZE	3

/*OV_RESULT CtreeUplaod_init(CtreeUpload* pupload, OV_INSTPTR_CTree_Upload pinst) {
	OV_RESULT res = OV_ERR_OK;
	pupload->root_path = "";
	ov_string_append(&pupload->root_path, pinst->v_root);
	pupload->proot = ov_path_getobjectpointer(pinst->v_root, VERSION_FOR_CTREE);

	//TODO: find out from object
//	ov_string_setvalue(&pupload->pinst->p_apiSet.v_serverHost, "localhost");
//	ov_string_setvalue(&pupload->pinst->p_apiSet.v_serverName, "MANAGER");

	return res;
}*/

//OV_RESULT CTree_log(OV_INSTPTR_CTree_Upload pinst, OV_MSG_TYPE msg_type,
//		const OV_STRING format, ...) {
//	OV_RESULT res = OV_ERR_OK;
//	va_list args;
//
//	ov_string_print(&pinst->v_log, format, args);
//	if (msg_type == OV_MT_ERROR)
//		ov_string_print(&pinst->v_errorLog, format, args);
//
//	/*
//	 *	print text to logfile
//	 */
//	va_start(args, format);
//#if OV_SYSTEM_UNIX && !OV_SYSTEM_SOLARIS
//	vsnprintf(pinst->v_cache.msg, sizeof(pinst->v_cache.msg), format, args);
//#else
//	vsprintf(pinst->v_cache.msg, format, args);
//#endif
//	va_end(args);
//	ov_logfile_print(msg_type, pinst->v_cache.msg);
//	return res;
//}

OV_RESULT Upload_log_exit(OV_INSTPTR_CTree_Upload pinst, OV_MSG_TYPE msg_type, OV_RESULT result,
		 const OV_STRING format, ...) {
	char msg[1024];

	cJSON_free(pinst->v_cache.jsbase);
	ov_string_setvalue(&pinst->v_json, "");
	va_list args;

	pinst->v_result = result;
	va_start(args, format);

#if OV_SYSTEM_UNIX && !OV_SYSTEM_SOLARIS
	vsnprintf(msg, sizeof(msg), format, args);
#else
	vsprintf(msg, format, args);
#endif
	va_end(args);

	ov_logfile_print(msg_type, msg);

	ov_string_append(&pinst->v_log, msg);
	ov_string_append(&pinst->v_log, "\n");
	ov_string_append(&pinst->v_log, ov_result_getresulttext(result));
	ov_string_append(&pinst->v_log, "\n");

	ov_string_append(&pinst->v_errorLog, ov_result_getresulttext(result));
	ov_string_append(&pinst->v_errorLog, "\n");
	ov_string_append(&pinst->v_errorLog, msg);
	ov_string_append(&pinst->v_errorLog, "\n");

	return result;
}

OV_ANY get_value_from_str(cJSON* jsvar) {
	OV_ANY value;
	value.state = OV_ST_GOOD;
	CTree_helper_strToOVType(&value.value.vartype,
			cJSON_GetArrayItem(jsvar, VARTYPE_POS)->valuestring);
	CTree_helper_strToValue(&value.value,
			cJSON_GetArrayItem(jsvar, VARVAL_POS)->valuestring);
	return value;
}

OV_RESULT set_variable_values(OV_INSTPTR_CTree_Upload pinst, cJSON* jsvariables,
		OV_INSTPTR_ov_object pobj) {
	/*
	 *	parameter and result objects
	 */
//	OV_INSTPTR_ksapi_setVar papiSet = &(pupload->pinst->p_apiSet);
	OV_RESULT res = OV_ERR_OK;

	cJSON* jsvariable = NULL;
	OV_UINT number_of_variables = cJSON_GetArraySize(jsvariables);
	OV_STRING objpathwithpunct = NULL;

	OV_SETVAR_PAR params;
	OV_SETVAR_RES result;
	OV_SETVAR_ITEM *addrp = NULL;

	OV_TICKET* pticket = NULL;

	//object path
	ov_memstack_lock();
	ov_string_setvalue(&objpathwithpunct,
			ov_path_getcanonicalpath(pobj, VERSION_FOR_CTREE));
	ov_string_append(&objpathwithpunct, ".");
	ov_memstack_unlock();

	//TODO: check json value

	ov_memstack_lock();
	addrp = (OV_SETVAR_ITEM*) ov_memstack_alloc(
			number_of_variables * sizeof(OV_SETVAR_ITEM));

	if (!addrp) {
		ov_memstack_unlock();
		res = OV_ERR_TARGETGENERIC;
		Upload_log_exit(pinst, res, OV_MT_ERROR, "%s",
				": internal memory problem");
		return res;
	}

	params.items_val = addrp;
	params.items_len = number_of_variables;

	//create NONE-ticket
	pticket = ksbase_NoneAuth->v_ticket.vtbl->createticket(NULL, OV_TT_NONE);

	//#####################################################################
	//process multiple variables at once
	cJSON_ArrayForEach(jsvariable, jsvariables)
	{
		addrp->var_current_props.value = get_value_from_str(jsvariable).value;
		//TODO:check for vartype and value

		OV_STRING strlist[] = { objpathwithpunct, jsvariable->string };
		OV_STRING_VEC variable_path = { .veclen = 2, .value = strlist };
		addrp->path_and_name = CTree_helper_strlistcat(&variable_path);

		//add one size of a pointer
		addrp++;
	}

	ov_ksserver_setvar(2, pticket, &params, &result);

	/*	delete Ticket	*/
	pticket->vtbl->deleteticket(pticket);

	/**
	 * Parse result from KS function
	 */

	if (Ov_Fail(result.result)) {
		//memory problem or NOACCESS
//			kshttp_print_result_array(&response->contentString, request.response_format, &result.result, 1, ": NOACCESS or memory problem");
		ov_memstack_unlock();
		return result.result;
	}
	for (int i = 0; i < result.results_len; i++) {
//		OV_STRING resstring = NULL;
//		ov_string_setvalue(&resstring, ov_result_getresulttext(result.results_val[i]));
		if((result.results_val[i] != OV_ERR_OK) && (result.results_val[i] !=OV_ERR_NOACCESS))
			CTree_log(pinst, OV_MT_WARNING, "%s returns OV_RESULT: %i", params.items_val[i].path_and_name, result.results_val[i]);
	}
//		fr = kshttp_print_result_array(&response->contentString, request.response_format, result.results_val, result.results_len, "");

	ov_memstack_unlock();
	return res;
}

OV_RESULT upload_tree(OV_INSTPTR_CTree_Upload pinst, cJSON* jsparent,
		OV_INSTPTR_ov_domain pparent) {

	OV_RESULT res = OV_ERR_OK;

	OV_INSTPTR_ov_class pclass = NULL;
	OV_INSTPTR_ov_object pobj = NULL;
	OV_INSTPTR_ov_object pclassobj = NULL;
	OV_STRING identifier = NULL;

	cJSON* jschild = NULL;
	cJSON* jscurrent = NULL;
	OV_STRING parentpath = NULL;

	//TODO: find more elegant solution to get path
	ov_memstack_lock();
	ov_string_setvalue(&parentpath,
			ov_path_getcanonicalpath(Ov_PtrUpCast(ov_object, pparent),
			VERSION_FOR_CTREE));
	ov_memstack_unlock();

	cJSON_ArrayForEach(jschild, jsparent)
	{
//		1. Getting identifier
		ov_string_setvalue(&identifier, jschild->string);
		if (!identifier) {
			return OV_ERR_BADPARAM;
		}

//		2. Getting class pointer
		jscurrent = cJSON_GetObjectItemCaseSensitive(jschild, "factory");
		OV_STRING factory = cJSON_GetStringValue(jscurrent);
		pclassobj = ov_path_getobjectpointer(factory, VERSION_FOR_CTREE);
		if (pclassobj == NULL) {
			CTree_log(pinst, OV_MT_ERROR,
					"There is no class with path %s", factory);
		}
		pclass = Ov_StaticPtrCast(ov_class, pclassobj);
		if (pclass == NULL) {
			CTree_log(pinst, OV_MT_ERROR,
					"There is no class with path %s", factory);
		}

//		3. Creating Object
		res =
				ov_class_createobject(pclass,
						((OV_INSTPTR_ov_domain) ((pparent)
								+ (0
										* ((pparent)->__classinfo.is_of_class_ov_domain)))),
						identifier, ((OV_PLACEMENT_HINT) 0), ((void *) 0),
						((void *) 0), ((void *) 0),
						((OV_INSTPTR_ov_object*) &(pobj)));
		if (Ov_Fail(res)) {
			if (res == OV_ERR_ALREADYEXISTS) {
				//TODO: check if it is from same class
				OV_STRING strvalue[] = { parentpath, "/", identifier };
				OV_STRING_VEC strvector = { .veclen = 3, .value = strvalue };
				pobj = ov_path_getobjectpointer(
						CTree_helper_strlistcat(&strvector),
						VERSION_FOR_CTREE);
				CTree_log(pinst, OV_MT_WARNING, "%s already exists",
						identifier);
			} else {
				return Upload_log_exit(pinst, res, OV_MT_ERROR,
						"Could not create %s in %s", identifier, parentpath);
			}
		} else {
			CTree_log(pinst, OV_MT_INFO, "created %s/%s", parentpath,
					identifier);
		}

		//	1. Set Variables
		cJSON* jsvariables = cJSON_GetObjectItemCaseSensitive(jschild,
				"variables");

		res = set_variable_values(pinst, jsvariables, pobj);
		if(Ov_OK(res))
			CTree_log(pinst, OV_MT_INFO, "variables set.");

		res = upload_tree(pinst, cJSON_GetObjectItem(jschild, "children"),
				Ov_StaticPtrCast(ov_domain, pobj));
		if (Ov_Fail(res)) {
			//TODO: give more info
			return Upload_log_exit(pinst, res, OV_MT_ERROR,
					"Could not load tree. error at %s", parentpath);
		}
	}
	return res;
}

OV_RESULT upload_libraries(OV_INSTPTR_CTree_Upload pinst, const cJSON* jslibs) {
	cJSON* current = NULL;
	OV_INSTPTR_ov_library plib = NULL;
	OV_RESULT res = 0;

	cJSON_ArrayForEach(current, jslibs)
	{
		if (!cJSON_IsString(current)) {
			return OV_ERR_BADPARAM;
		}
		OV_STRING libname = cJSON_GetStringValue(current);
		plib = ov_library_search(libname);
		res = Ov_CreateObject(ov_library, plib, &(pdb->acplt), libname);

		//	2.3 check if loaded successfully?
		switch (res) {
		case OV_ERR_OK:
			CTree_log(Ov_StaticPtrCast(CTree_CTreeCommon, pinst), OV_MT_INFO, "Library %s loaded", libname);
			break;
		case OV_ERR_ALREADYEXISTS:
			CTree_log(pinst, OV_MT_INFO, "Library %s exists", libname);
			break;
		default:
			return Upload_log_exit(pinst, res, OV_MT_ERROR,
					"Could not load library %s", libname);
		}
	}
	return res;
}

OV_RESULT link_objects(const cJSON* jslinks) {
	OV_RESULT res = OV_ERR_OK;
	cJSON* jschild = NULL;
	cJSON* current = NULL;
	OV_INSTPTR_ov_association passoc = NULL;
	OV_INSTPTR_ov_object pparent = NULL;
	OV_INSTPTR_ov_object pchild = NULL;

	if (jslinks == NULL)
		return OV_ERR_BADPARAM;

	cJSON_ArrayForEach(jschild, jslinks)
	{
		current = cJSON_GetObjectItem(jschild, "of_association");
		passoc =
				Ov_StaticPtrCast(ov_association,
						ov_path_getobjectpointer(cJSON_GetStringValue(current), VERSION_FOR_CTREE));

		cJSON* jsasparent = NULL;
		cJSON* jsasparents = cJSON_GetObjectItem(jschild, "parents");

		cJSON_ArrayForEach(jsasparent, jsasparents)
		{
			pparent = ov_path_getobjectpointer(cJSON_GetStringValue(jsasparent),
			VERSION_FOR_CTREE);
			if (pparent == NULL) {
				ov_logfile_error("%s does not exist",
						cJSON_GetStringValue(jsasparent));
				continue;
				//			return OV_ERR_BADPARAM;
			}

			cJSON* jsaschild = NULL;
			cJSON* jsaschildren = cJSON_GetObjectItem(jschild, "children");
			cJSON_ArrayForEach(jsaschild, jsaschildren)
			{
				OV_STRING path = cJSON_GetStringValue(jsaschild);
				pchild = ov_path_getobjectpointer(path, VERSION_FOR_CTREE);
				if (pchild == NULL) {
					ov_logfile_error("%s does not exist", path);
					continue;
					//			return OV_ERR_BADPARAM;
				}

				res = ov_association_link(passoc, pparent, pchild,
				OV_PMH_DEFAULT, NULL, OV_PMH_DEFAULT, NULL);
				if (Ov_OK(res))
					ov_logfile_info("%s linked with %s through %s",
							pparent->v_identifier, pchild->v_identifier,
							passoc->v_identifier);
				else {
					if (res == OV_ERR_ALREADYEXISTS) {
						ov_logfile_warning(
								"%s is already linked with %s through %s",
								pparent->v_identifier, pchild->v_identifier,
								passoc->v_identifier);
						res = OV_ERR_OK;
					} else {
						ov_logfile_error(
								"%s can not be linked with %s through %s",
								pparent->v_identifier, pchild->v_identifier,
								passoc->v_identifier);
						res = OV_ERR_OK;
						//!!!
					}
				}
			}
		}

	}
	return res;
}

OV_DLLFNCEXPORT void CTree_Upload_submit(OV_INSTPTR_CTree_CTreeCommon pobj) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_CTree_Upload pinst = Ov_StaticPtrCast(CTree_Upload, pobj);

//    ov_string_setvalue(&pinst->v_json, "{\"Path\":\"/TechUnits\", \"Tree\":{\"A\":{\"factory\":\"/acplt/CTree/Upload\",\"variables\":{},\"children\":{\"AA\":{\"factory\":\"/acplt/CTree/Upload\",\"variables\":{},\"children\":{}}}}},\"Links\":{},\"Libraries\":[\"CTree\",\"ksapi\"]}");
	OV_RESULT res;

	//1. parse input
	cJSON * jsbase = pinst->v_cache.jsbase = NULL;
	cJSON * jslibs = pinst->v_cache.jslibs = NULL;
	cJSON * jslinks = pinst->v_cache.jslinks = NULL;
	cJSON * jstree = pinst->v_cache.jstree = NULL;
//	cJSON * jspath = pinst->v_cache.jspath = NULL;
//	cJSON * current = NULL;

	jsbase = cJSON_Parse(pinst->v_json);
	//1.1 check if file is ok
	if (jsbase == NULL) {
		const char *error_ptr = cJSON_GetErrorPtr();
		if (error_ptr != NULL) {
//			print_log(pinst, ov_logfile_error, "bad js file");
		}
		Upload_log_exit(pinst, OV_ERR_BADPARAM, OV_MT_ERROR,
				"Bad json file");
		return;
	}
	CTree_log(pinst, OV_MT_INFO, "parsed successfully");

//   2. Load Libraries
//   2.1 jsbase contains libraries?
	jslibs = cJSON_GetObjectItem(jsbase, "Libraries");
	if (jslibs == NULL) {
		CTree_log(pinst, OV_MT_INFO, "No libraries to load");
	}

//  2.2 load
	res = upload_libraries(pinst, jslibs);
//  2.3 successfully?
	if (Ov_Fail(res))
		if (res != OV_ERR_ALREADYEXISTS) {
			Upload_log_exit(pinst, OV_MT_ERROR, res,
					"Could not load dependent libraries");
			return;
		}

//	3. CreateObjects Iteratively
	jstree = cJSON_GetObjectItem(jsbase, "Tree");

	OV_STRING rootpath = NULL;
	ov_string_setvalue(&rootpath,
			cJSON_GetStringValue(cJSON_GetObjectItem(jsbase, "Path")));

	OV_INSTPTR_ov_object proot = ov_path_getobjectpointer(rootpath,
	VERSION_FOR_CTREE);
	upload_tree(pinst, jstree, Ov_StaticPtrCast(ov_domain, proot));

//	4. Link
	jslinks = cJSON_GetObjectItem(jsbase, "Links");
	link_objects(jslinks);

	// Free memory
	Upload_log_exit(pinst, OV_MT_INFO, res, "%s", "Upload done.");
	return;
}

