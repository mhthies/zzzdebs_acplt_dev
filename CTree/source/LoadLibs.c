/******************************************************************************
 *
 *   FILE
 *   ----
 *   LoadLibs.c
 *
 *   History
 *   -------
 *   2018-03-29   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/

#ifndef OV_COMPILE_LIBRARY_CTree
#define OV_COMPILE_LIBRARY_CTree
#endif

#include <stdio.h>
#include <unistd.h>
#include <string.h>

#include "CTree.h"
#include "libov/ov_macros.h"
#include "libov/ov_result.h"
#include "libov/ov_logfile.h"
#include "libov/ov_string.h"
#include "NoneTicketAuthenticator.h"
#include "libov/ov_debug.h"

#include "ksapi.h"

OV_DLLFNCEXPORT OV_RESULT CTree_LoadLibs_constructor(OV_INSTPTR_ov_object pobj) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_CTree_LoadLibs pinst = Ov_StaticPtrCast(CTree_LoadLibs, pobj);
	OV_RESULT result;

	/* do what the base class does first */
	result = fb_functionblock_constructor(pobj);
	if (Ov_Fail(result))
		return result;

	/* do what */

	return OV_ERR_OK;
}

OV_DLLFNCEXPORT void CTree_LoadLibs_destructor(OV_INSTPTR_ov_object pobj) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_CTree_LoadLibs pinst = Ov_StaticPtrCast(CTree_LoadLibs, pobj);

	/* do what */
	/* destroy object */
	fb_functionblock_destructor(pobj);

	return;
}

OV_DLLFNCEXPORT void CTree_LoadLibs_startup(OV_INSTPTR_ov_object pobj) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_CTree_LoadLibs pinst = Ov_StaticPtrCast(CTree_LoadLibs, pobj);

	/* do what the base class does first */
	fb_functionblock_startup(pobj);

	/* do what */
	pinst->p_eks.v_actimode = 1;
	return;
}

OV_DLLFNCEXPORT void CTree_LoadLibs_shutdown(OV_INSTPTR_ov_object pobj) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_CTree_LoadLibs pinst = Ov_StaticPtrCast(CTree_LoadLibs, pobj);

	/* do what */
	/* set the object's state to "shut down" */
	fb_functionblock_shutdown(pobj);

	return;
}

OV_RESULT libToBytes(OV_STRING libname, OV_BYTE_VEC * bvec) {
	OV_RESULT result = OV_ERR_OK;
	FILE * lib = NULL;
	ov_memstack_lock();
	OV_STRING libpath = NULL;
	OV_UINT number_of_bytes = 0;

	ov_string_print(&libpath, "../addonlibs/%s.so", libname);
	lib = fopen(libpath, "rb");
	if (!lib) {
		return OV_ERR_GENERIC;
	}

	fseek(lib, 0L, SEEK_END);
	number_of_bytes = ftell(lib);
	rewind(lib);

	bvec->value = (OV_BYTE*) ov_memstack_alloc(
			number_of_bytes * sizeof(OV_BYTE));
	bvec->veclen = fread(bvec->value, sizeof(OV_BYTE), number_of_bytes, lib);
	if (bvec->veclen == -1)
		return OV_ERR_GENERIC;

	if (!lib)
		fclose(lib);
	ov_memstack_unlock();
	return result;

}

OV_RESULT bytesToLib(OV_STRING libname, const OV_BYTE_VEC * bvec) {
	OV_RESULT result = OV_ERR_OK;
	FILE * target_lib = NULL;
	target_lib = fopen("../addonlibs/test.so", "wb");
	OV_UINT tmp = fwrite(bvec->value, sizeof(OV_BYTE), bvec->veclen,
			target_lib);
	if (tmp != bvec->veclen)
		ov_logfile_error("not enough");

	if (!target_lib)
		fclose(target_lib);
	return result;
}

OV_RESULT copy_library(OV_STRING libname) {
	OV_RESULT result = OV_ERR_OK;
	OV_BYTE_VEC bvec = { 0 };

//	result = get_targetserver_info();

	result = libToBytes(libname, &bvec);
	if (Ov_Fail(result))
		ov_logfile_error("error1 %s", ov_result_getresulttext(result));

	return result;
}

OV_RESULT send_libs(OV_INSTPTR_CTree_LoadLibs pinst, OV_BYTE_VEC blibs[],
		OV_UINT liblen) {
	OV_RESULT result = OV_ERR_OK;

	OV_INSTPTR_ksbase_ClientBase pClient = NULL;
	OV_VTBLPTR_ksbase_ClientBase pVtblClient = NULL;

	/*	OV_RESULT result;
	 OV_SETVAR_ITEM* items = NULL;
	 OV_UINT numberOfItems = liblen;
	 OV_STRING path = NULL;
	 OV_UINT len = 0;
	 OV_STRING * splited = NULL;

	 result = CTree_Transport_prepareSubmit(pinst, &pClient, &pVtblClient);
	 if (Ov_Fail(result))
	 return result;

	 items = Ov_HeapMalloc(numberOfItems * sizeof(OV_SETVAR_ITEM));
	 if (!items) {
	 pinst->v_status = CTREE_COMMON_INTERNALERROR;
	 pinst->v_result = OV_ERR_HEAPOUTOFMEMORY;
	 return result;
	 }

	 splited = ov_string_split(pinst->v_targetKS, ":", &len);
	 if (len > 2)
	 path = splited[2];
	 else
	 path = "/data/CTree/Upload";

	 for(OV_UINT i=0; i<liblen; i++){
	 items[i].path_and_name = NULL;
	 ov_string_print(&items[0].path_and_name, "%s.%s", path, "json"); 	see comment below
	 items[0].var_current_props.value.vartype = KS_VT_BYTE_VEC;
	 items[0].var_current_props.value.valueunion.val_byte_vec= pinst->v_tree;
	 items[1].path_and_name = "";
	 ov_string_print(&items[1].path_and_name, "%s.%s", path, "path");
	 items[1].var_current_props.value.vartype = KS_VT_STRING;
	 items[1].var_current_props.value.valueunion.val_string =
	 pinst->v_targetPath;

	 } else {
	 ov_logfile_error("%s: submit: own Variable has empty path",
	 pinst->v_identifier);
	 pinst->v_status = CTREE_COMMON_INTERNALERROR;
	 pinst->v_result = result;
	 Ov_HeapFree(items);
	 return result;
	 }

	 do the actual submit
	 pVtblClient->m_requestSetVar(pClient, NULL, numberOfItems, items,
	 (OV_INSTPTR_ov_domain) pinst, &CTree_Transport_exec_callback);

	 if (!(pClient->v_state & KSBASE_CLST_ERROR))
	 pinst->v_status = CTREE_COMMON_WAITINGFORANSWER;
	 else
	 pinst->v_status = CTREE_COMMON_INTERNALERROR;

	 Ov_HeapFree(items);

	 return result;*/

	return result;
}

#define EKS_COMMON_INITIAL				0
#define EKS_COMMON_WAITINGFORANSWER		1
#define EKS_COMMON_REQUESTCOMPLETED		2

OV_BOOL strvec_contains(const OV_STRING_VEC * vec, const OV_STRING str) {
	for (OV_UINT i = 0; i < vec->veclen; i++) {
		if (!ov_string_compare(vec->value[i], str))
			return 1;
	}
	return 0;
}

OV_RESULT CTree_LoadLibs_execute(OV_INSTPTR_CTree_LoadLibs pinst) {
	OV_RESULT result = OV_ERR_OK;
	OV_STRING os = NULL;
	OV_STRING target_os = NULL;
	OV_UINT target_arch = 0;
	OV_UINT arch = 0;

	OV_STRING_VEC libsToSend = { 0 };
	OV_STRING_VEC libs = { 0 };

	OV_STRING_VEC * ptarget_libs = NULL;

	OV_BYTE_VEC blibs = {0, NULL};
	OV_UINT_VEC	libPositions = {0, NULL};

	enum format {
		OS, ARCH, LIBS, FORMATLEN
	};

	/*
	 * 1. get own os and arch
	 */
	OV_GETVAR_PAR gvParam = { 0 };
	OV_GETVAR_RES gvResult = { 0 };
	OV_TICKET* pticket = NULL;

	ov_memstack_lock();
//	pticket = ksbase_NoneAuth->v_ticket.vtbl->createticket(NULL, OV_TT_NONE);
//	gvParam.identifiers_len = 3;
//	OV_STRING paths[3] = { "/data/CTree/dbinfo.serversystem",
//			"/data/CTree/dbinfo.serversystemarch", "/data/CTree/dbinfo.libs" };
//	gvParam.identifiers_val = paths;
//
//	ov_ksserver_getvar(2, pticket, &gvParam, &gvResult);
//
//	if (!gvResult.result && !gvResult.items_val[0].result
//			&& !gvResult.items_val[1].result && !gvResult.items_val[2].result) {
//		arch =
//				gvResult.items_val[ARCH].var_current_props.value.valueunion.val_uint;
//		os =
//				gvResult.items_val[OS].var_current_props.value.valueunion.val_string;
//	}
	/*
	 * 2. get target info os and architect and libs
	 */
	OV_STRING serverHost = "localhost";
	OV_STRING serverName = "MANAGER";
//
	OV_STRING targetpaths[FORMATLEN] = { [OS
			] = "/data/CTree/dbinfo.serversystem", [ARCH
			] = "/data/CTree/dbinfo.serversystemarch", [LIBS
			] = "/data/CTree/dbinfo.libs" };

	OV_GETVAR_PAR tar_gvParam = { 3, NULL };
	tar_gvParam.identifiers_val = targetpaths;
	OV_GETVAR_RES tar_gvResult = { 1, 0, NULL };
//
	eks_client_setParam(&pinst->p_eks, serverHost, serverName);
	eks_client_getVar(&pinst->p_eks, &tar_gvParam, &tar_gvResult);

//	Ov_AbortIf(tar_gvResult.items_val[LIBS].var_current_props.value.vartype != OV_VT_STRING_VEC);
	if (!tar_gvResult.result && !tar_gvResult.items_val[0].result
			&& !tar_gvResult.items_val[1].result
			&& !tar_gvResult.items_val[2].result) {
		target_arch =
				tar_gvResult.items_val[ARCH].var_current_props.value.valueunion.val_uint;
		target_os =
				tar_gvResult.items_val[OS].var_current_props.value.valueunion.val_string;
		ov_logfile_info("%u: %s", target_arch, target_os);
//		ptarget_libs = &tar_gvResult.items_val[OS].var_current_props.value.valueunion.val_string_vec;
	} else {
		ov_logfile_error("result");
		//TODO: info
//		return OV_ERR_GENERIC;
	}
//
//	/*
//	 * 3. compare os and arch
//	 */
//	if (arch
//			!= target_arch|| ov_string_compare(os, target_os)!=OV_STRCMP_EQUAL) {
//		ov_logfile_error("Target os or arch is different from local");
//		return OV_ERR_GENERIC;
//	} else {
//		//TODO: info
//		return OV_ERR_GENERIC;
//	}
//	/*
//	 * 4. Find out libs to transport
//	 */
//	for (OV_UINT i = 0; i < libs.veclen; i++) {
//		if (strvec_contains(ptarget_libs, libs.value[i])) {
//			libsToSend.veclen++;
//		}
//	}
//	/*
//	 * 5. convert libs to OV_BYTE_VEC
//	 */
//	ov_memstack_lock();
//	blibs = (OV_BYTE_VEC*) ov_memstack_alloc(
//			libsToSend.veclen * sizeof(OV_BYTE_VEC));
//	for (OV_UINT i = 0; i < libsToSend.veclen; i++) {
//		result = libToBytes(libsToSend.value[i], &blibs[i]);
//		if (Ov_Fail(result)) {
//			//TODO: info
//			return result;
//		}
//	}
	/*
	 * 6. send libs
	 */
	OV_SETVAR_PAR svParam = { 0, NULL };
	OV_SETVAR_RES svResult = { 1, 0, NULL };

	svParam.items_len = 1;
	svParam.items_val = ov_memstack_alloc(
			svParam.items_len * sizeof(OV_SETVAR_ITEM));
	OV_STRING path = NULL;
	ov_string_setvalue(&path, "/TechUnits/download.path");
	svParam.items_val[0].path_and_name = path;
	svParam.items_val[0].var_current_props.value.vartype = OV_VT_STRING;
	OV_STRING value = NULL;
	ov_string_setvalue(&value, "test");
	svParam.items_val[0].var_current_props.value.valueunion.val_string = value;

	eks_client_setVar(&pinst->p_eks, &svParam, &svResult);
	ov_memstack_unlock();

	return result;
}

OV_DLLFNCEXPORT void CTree_LoadLibs_typemethod(OV_INSTPTR_fb_functionblock pfb,
		OV_TIME *pltc) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_CTree_LoadLibs pinst = Ov_StaticPtrCast(CTree_LoadLibs, pfb);
	OV_RESULT result = CTree_LoadLibs_execute(pinst);

	return;
}

