/******************************************************************************
 *
 *   FILE
 *   ----
 *   Download.c
 *
 *   History
 *   -------
 *   2018-02-27   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/

#define OV_DEBUG

#ifndef OV_COMPILE_LIBRARY_CTree
#define OV_COMPILE_LIBRARY_CTree
#endif

#include "CTree.h"
#include "libov/ov_macros.h"
#include "libov/ov_string.h"
#include "libov/ov_library.h"
#include "libov/ov_path.h"
#include "libov/ov_element.h"
#include "libov/ov_result.h"
#include "libov/ov_object.h"
#include "libov/ov_variable.h"

#include "cJSON.h"

#include "libov/ov_debug.h"

#define VERSION_FOR_CTREE 	2

OV_RESULT crawl_tree(const OV_INSTPTR_ov_domain pobj, cJSON* jsobj,
		cJSON* jslibs, OV_BOOL getvariables);

OV_RESULT get_variables(const OV_INSTPTR_ov_object pobj, cJSON* jsvars,
		OV_ELEM_TYPE mask);

OV_RESULT crawl_links(cJSON* jslibs, const OV_ELEMENT* pelobj);

OV_RESULT write_link(cJSON* jslinks, OV_ELEMENT* pelassoc);

OV_DLLFNCEXPORT void CTree_Download_typemethod(OV_INSTPTR_fb_functionblock pfb,
		OV_TIME *pltc) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_CTree_Download pinst = Ov_StaticPtrCast(CTree_Download, pfb);
	OV_INSTPTR_ov_domain root = NULL;

	OV_RESULT res = 0;

	cJSON* jsbase = cJSON_CreateObject();
	cJSON* jstree = NULL;
	cJSON* jslinks = NULL;
	cJSON* jslibs = NULL; //non free
//	cJSON* current = NULL;

	root = Ov_StaticPtrCast(ov_domain,
			ov_path_getobjectpointer(pinst->v_root, VERSION_FOR_CTREE));

	if (root == NULL) {
		ov_logfile_error("%s couldnt be found", pinst->v_root);
		pinst->v_return = OV_ERR_BADPARAM;
		cJSON_free(jsbase);
		return;
	}
	//!!!check if root is accessable

	jslibs = cJSON_AddArrayToObject(jsbase, "Libraries");
	jstree = cJSON_AddObjectToObject(jsbase, "Tree");
	cJSON_AddStringToObject(jsbase, "Path", pinst->v_root);
	jslinks = cJSON_AddArrayToObject(jsbase, "Links");

	OV_INSTPTR_ov_domain pchild = NULL;
	//crawling

	Ov_ForEachChild(ov_containment, root, pchild)
	{
		cJSON* jschild = cJSON_AddObjectToObject(jstree, pchild->v_identifier);
		res = crawl_tree(pchild, jschild, jslibs, pinst->v_getvar);
		if (Ov_Fail(res)) {
			pinst->v_return = res;
			cJSON_free(jsbase);
			return;
		}
	}

	//checking libs and tree

	//links
	OV_ELEMENT elroot;
	elroot.elemtype = OV_ET_OBJECT;
	elroot.pobj = root;

	res = crawl_links(jslinks, &elroot);
	if (Ov_Fail(res)) {
		pinst->v_return = res;
		cJSON_free(jsbase);
		return;
	}

	res = ov_string_setvalue(&pinst->v_tree, cJSON_Print(jsbase));
	if (Ov_Fail(res)) {
		pinst->v_return = res;
		cJSON_free(jsbase);
		return;
	}
	res = ov_string_setvalue(&pinst->v_libs, cJSON_Print(jslibs));
	if (Ov_Fail(res)) {
		pinst->v_return = res;
		cJSON_free(jsbase);
		return;
	}
	cJSON_free(jsbase);
	return;
}

OV_RESULT crawl_links(cJSON* jslinks, const OV_ELEMENT* pelobj) {

	OV_RESULT res = OV_ERR_OK;

//	get_links(jslinks, pelobj, OV_ET_PARENTLINK);
	get_links(jslinks, pelobj, OV_ET_CHILDLINK);

	OV_ELEMENT elchild;
	elchild.elemtype = OV_ET_NONE;

	ov_element_getnextchild(pelobj, &elchild);
	while (elchild.elemtype == OV_ET_OBJECT) {

		res = crawl_links(jslinks, &elchild);
		if (Ov_Fail(res))
			return res;
		ov_element_getnextchild(pelobj, &elchild);
	}
}


OV_RESULT get_links(cJSON* jslinks, OV_ELEMENT* pelobj, OV_ELEM_TYPE mask) {
	OV_RESULT res = OV_ERR_OK;

	OV_ELEMENT elvar;
	elvar.elemtype = OV_ET_NONE;

	while (TRUE) {
		//get links
		res = ov_element_getnextpart(pelobj, &elvar, mask);
		if (Ov_Fail(res)) {
			ov_logfile_error("%s", ov_result_getresulttext(res));
			return res;
		}
		if (elvar.elemtype == OV_ET_NONE)
			break;

		res = write_link(jslinks, &elvar);
		if (res == OV_ERR_OPTYPEDEFMISMATCH) {
			res = OV_ERR_OK;
		}
	}
	return res;
}

OV_RESULT write_link(cJSON* jslinks, OV_ELEMENT* pelassoc) {
	OV_RESULT res = OV_ERR_OK;

	OV_INSTPTR_ov_association passoc = pelassoc->elemunion.passoc;

	cJSON* jsparent = NULL;
	cJSON* jschild = NULL;
	cJSON* current = cJSON_CreateObject();

	OV_INSTPTR_ov_object pparent = NULL;
	OV_INSTPTR_ov_object pchild = NULL;

	//of_association
	ov_memstack_lock();
	OV_STRING factory = ov_path_getcanonicalpath(Ov_PtrUpCast(ov_object, passoc), VERSION_FOR_CTREE);
	ov_memstack_unlock();
	if (ov_string_match(factory, "*/ov/containment")
			|| ov_string_match(factory, "*/ov/instantiation"))
		return OV_ERR_OPTYPEDEFMISMATCH;

	cJSON_AddStringToObject(current, "of_association", factory);
	cJSON_AddItemToArray(jslinks, current);

	jsparent = cJSON_AddArrayToObject(current, "parent");
	cJSON_AddItemToArray(jsparent,
			cJSON_CreateString(passoc->v_parentrolename));

	jschild = cJSON_AddArrayToObject(current, "children");
	cJSON_AddItemToArray(jschild, cJSON_CreateString(passoc->v_childrolename));

	switch (passoc->v_assoctype) {
	case OV_AT_ONE_TO_MANY:
		pparent = Ov_Association_GetParent(passoc, pelassoc->pobj);
		ov_memstack_lock();
		OV_STRING factory = ov_path_getcanonicalpath(pparent,
				VERSION_FOR_CTREE);
		cJSON_AddItemToArray(jsparent, cJSON_CreateString(factory));
		ov_memstack_unlock();

		ov_memstack_lock();
		factory = ov_path_getcanonicalpath(pelassoc->pobj,
				VERSION_FOR_CTREE);
		cJSON_AddItemToArray(jschild, cJSON_CreateString(factory));
		ov_memstack_unlock();

//		Ov_Association_ForEachChild(passoc, pparent, pchild){
//			ov_memstack_lock();
//			OV_STRING factory = ov_path_getcanonicalpath(pchild, VERSION_FOR_CTREE);
//			cJSON_AddItemToArray(jschild, cJSON_CreateString(factory));
//			ov_memstack_unlock();
//		}

		break;
	case OV_AT_MANY_TO_MANY:
		Ov_Error("many to many")
		;
		break;
	case OV_AT_ONE_TO_ONE:
		Ov_Error("one to one")
		;
		break;
	}

	return res;
}

OV_RESULT get_variables(const OV_INSTPTR_ov_object pobj, cJSON* jsvars,
		OV_ELEM_TYPE mask) {
	OV_RESULT res = OV_ERR_OK;

	OV_INSTPTR_ov_object pchild;

	OV_ELEMENT elparent;
	elparent.elemtype = OV_ET_OBJECT;
	elparent.pobj = pobj;

	OV_VTBLPTR_ov_object pVtblObj = NULL;

	OV_ELEMENT elvar;
	elvar.elemtype = OV_ET_NONE;

	OV_ANY value;
	cJSON* jschild = NULL;

	Ov_GetVTablePtr(ov_object, pVtblObj, pobj);
	while (TRUE) {
		//get variable element
		res = ov_element_getnextpart(&elparent, &elvar, mask);
		if (Ov_Fail(res)) {
			ov_logfile_error("%s", ov_result_getresulttext(res));
			return res;
		}
		if (elvar.elemtype == OV_ET_NONE)
			break;

		if (elvar.elemtype == mask)
			res = pVtblObj->m_getvar(elvar.pobj, &elvar, &value);

		switch (mask) {
		case OV_ET_NONE:/* invalid element */
		case OV_ET_OBJECT:
		case OV_ET_MEMBER: /* structure member (superseded by PART) */
		case OV_ET_OPERATION:
		case OV_ET_ANY:
			ov_logfile_info("Cannot handle it for now");
			break;
		case OV_ET_VARIABLE:
			jschild = cJSON_AddArrayToObject(jsvars,
					ov_element_getidentifier(&elvar));

//			ov_variable_initialvalue_get();
			cJSON_AddItemToArray(jschild, cJSON_CreateString("1"));

			OV_STRING valuestr = "";
//			ov_string_setvalue(&valuestr, "1");
			res = CTree_helper_valueToStr(&valuestr, &value.value);
			if (Ov_OK(res)) {
				cJSON_AddItemToArray(jschild, cJSON_CreateString(valuestr));
			}

			OV_STRING typestr;
//			ov_string_setvalue(&typestr, "1");
			res = CTree_helper_typeToStr(&typestr, &value.value.vartype);
			if (Ov_OK(res)) {
				cJSON_AddItemToArray(jschild, cJSON_CreateString(typestr));
			}
			break;
		case OV_ET_PARENTLINK:
			jschild = cJSON_AddArrayToObject(jsvars,
					ov_element_getidentifier(&elvar));

			cJSON_AddItemToArray(jschild, cJSON_CreateString("parentlink"));

			cJSON_AddItemToArray(jschild,
					cJSON_CreateString(
							elvar.elemunion.passoc->v_parentrolename));
			cJSON_AddItemToArray(jschild,
					cJSON_CreateString(
							elvar.elemunion.passoc->v_childrolename));

			ov_memstack_lock();
			cJSON_AddItemToArray(jschild,
					cJSON_CreateString(
							ov_path_getcanonicalpath(
									Ov_PtrUpCast(ov_object,
											elvar.elemunion.passoc),
									VERSION_FOR_CTREE)));
			ov_memstack_unlock();
			break;
		case OV_ET_CHILDLINK:
			jschild = cJSON_AddArrayToObject(jsvars,
					ov_element_getidentifier(&elvar));

			cJSON_AddItemToArray(jschild, cJSON_CreateString("childlink"));

			cJSON_AddItemToArray(jschild,
					cJSON_CreateString(
							elvar.elemunion.passoc->v_parentrolename));
			cJSON_AddItemToArray(jschild,
					cJSON_CreateString(
							elvar.elemunion.passoc->v_childrolename));

			ov_memstack_lock();
			cJSON_AddItemToArray(jschild,
					cJSON_CreateString(
							ov_path_getcanonicalpath(
									Ov_PtrUpCast(ov_object,
											elvar.elemunion.passoc),
									VERSION_FOR_CTREE)));
			ov_memstack_unlock();
		}
	}

	return res;
}

//OV_RESULT get_links(const OV_INSTPTR_ov_object pobj, OV_BOOL only_parent){
//
//	ov_element_getnextpart(&objElement, &elchild, OV_ET_PARENTLINK);
//}

OV_RESULT crawl_tree(const OV_INSTPTR_ov_domain pobj, cJSON* jsobj,
		cJSON* jslibs, OV_BOOL getvariables) {
	OV_RESULT res = 0;

	cJSON* current = NULL;

//variables
	if (getvariables) {
		current = cJSON_AddObjectToObject(jsobj, "variables");
		get_variables(Ov_PtrUpCast(ov_object, pobj), current, OV_ET_VARIABLE);
	}

//factory
	OV_STRING factory = CTree_helper_getfactory(pobj);
	cJSON_AddStringToObject(jsobj, "factory", factory);

//	libraries
	OV_UINT len = 0;
	OV_STRING* seperated = ov_string_split(factory, "/", &len);
	if (seperated == NULL)
		return OV_ERR_BADVALUE;

	if (len < 2)
		return OV_ERR_BADVALUE;

//	checks if the library already found.
	current = cJSON_GetObjectItem(jslibs, seperated[len - 2]);
	if (current == NULL)
		cJSON_AddStringToObject(jslibs, seperated[len - 2], seperated[len - 2]);

//children
	cJSON* jschildren = cJSON_AddObjectToObject(jsobj, "children");

//	if(!ov_string_compare(seperated[len-2], "fb") && !ov_string_compare(seperated[len-1], "connection"))
//	{
//		return res;
//	}
// test
	OV_ELEMENT objElement;
	objElement.elemtype = OV_ET_OBJECT;
	objElement.pobj = Ov_PtrUpCast(ov_object, pobj);

	OV_ELEMENT elchild;
	elchild.elemtype = OV_ET_NONE;
	ov_element_getnextchild(&objElement, &elchild);
	while (elchild.elemtype == OV_ET_OBJECT) {
		ov_logfile_info("%s", ov_element_getidentifier(&elchild));

		cJSON* jschild = cJSON_AddObjectToObject(jschildren,
				ov_element_getidentifier(&elchild));
		res = crawl_tree(Ov_StaticPtrCast(ov_domain, elchild.pobj), jschild,
				jslibs, getvariables);
		if (Ov_Fail(res))
			return res;
		ov_element_getnextchild(&objElement, &elchild);
	}

//	OV_ELEMENT ellink;
//	OV_ELEMENT objElement1;
//	objElement1.elemtype = OV_ET_OBJECT;
//	objElement1.pobj = Ov_PtrUpCast(ov_object, pobj);
//
//	ellink.elemtype = OV_ET_PARENTLINK;
//	ov_element_getnextpart(&objElement1, &ellink, OV_ET_PARENTLINK);
//	while (elchild.elemtype == OV_ET_PARENTLINK) {
//		ov_memstack_lock();
//		ov_string_setvalue(&factory,
//				ov_path_getcanonicalpath(
//						Ov_PtrUpCast(ov_object, ellink.elemunion.passoc),
//						VERSION_FOR_CTREE));
//		ov_memstack_unlock();
//		ov_logfile_debug("%s parent", factory);
//		ov_element_getnextpart(&objElement1, &ellink, OV_ET_PARENTLINK);
//	}
//	ov_element_getnextpart(&objElement, &elchild, OV_ET_CHILDLINK);
//	while (elchild.elemtype == OV_ET_CHILDLINK) {
//		ov_memstack_lock();
////		OV_INSTPTR_ov_object pparent =
////		OV_INSTPTR_ov_object pparobj = Ov_PtrUpCast(ov_object, pparent);
////		OV_STRING factory = ov_path_getcanonicalpath(pparobj, VERSION_FOR_CTREE);
//
//		ov_string_setvalue(&factory,
//				ov_path_getcanonicalpath(
//						Ov_PtrUpCast(ov_object, elchild.elemunion.passoc),
//						VERSION_FOR_CTREE));
//		ov_logfile_debug("%s child", factory);
//		ov_memstack_unlock();
//		ov_element_getnextpart(&objElement, &elchild, OV_ET_CHILDLINK);
//	}
	return res;
}

