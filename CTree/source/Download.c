
/******************************************************************************
*
*   FILE
*   ----
*   Download.c
*
*   History
*   -------
*   2018-02-27   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/

#define OV_DEBUG

#ifndef OV_COMPILE_LIBRARY_CTree
#define OV_COMPILE_LIBRARY_CTree
#endif


#include "CTree.h"
#include "libov/ov_macros.h"
#include "libov/ov_string.h"
#include "libov/ov_library.h"


#include "cJSON.h"

#include "libov/ov_debug.h"

#define VERSION_FOR_CTREE 	2

OV_RESULT crawl_tree(const OV_INSTPTR_ov_domain pobj,  cJSON* jsobj, cJSON* jslibs, OV_BOOL getvariables);

OV_DLLFNCEXPORT void CTree_Download_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    /*
    *   local variables
    */
    OV_INSTPTR_CTree_Download pinst = Ov_StaticPtrCast(CTree_Download, pfb);
    OV_INSTPTR_ov_domain root = NULL;

	OV_RESULT res = 0;

	cJSON* jstree = NULL;
	cJSON* jslibs	=	NULL; //non free
	cJSON* current = NULL;

	root = ov_path_getobjectpointer(pinst->v_root, VERSION_FOR_CTREE);
	if(root==NULL){
		pinst->v_return = OV_ERR_BADPARAM;
		cJSON_free(jstree);
		return;
	}
	//!!!check if root is accessable

	jslibs = cJSON_AddArrayToObject(jstree, "Libraries");
	cJSON_AddObjectToObject(jstree, "Tree");
	cJSON_AddStringToObject(jstree, "Path", pinst->v_root);

	//crawling
	res = crawl_tree(root, jstree, jslibs, pinst->v_getvar);
	if(Ov_Fail(res)){
		pinst->v_return = res;
		cJSON_free(jstree);
		return;
	}
	//checking libs and tree

	res = ov_string_setvalue(&pinst->v_tree, cJSON_Print(jstree));
	if(Ov_Fail(res)){
		pinst->v_return = res;
		cJSON_free(jstree);
		return;
	}
	res = ov_string_setvalue(&pinst->v_libs, cJSON_Print(jslibs));
	if(Ov_Fail(res)){
		pinst->v_return = res;
		cJSON_free(jstree);
		return;
	}
	cJSON_free(jstree);
    return;
}

OV_STRING get_factory(
		OV_INSTPTR_ov_domain pobj
	) {
	if(!pobj)
		return NULL;

	ov_memstack_lock();
	OV_INSTPTR pparent = Ov_GetParent(ov_instantiation, pobj);
	OV_INSTPTR pparobj = Ov_PtrUpCast(ov_object, pparent);
	OV_STRING factory = ov_path_getcanonicalpath(pparobj, 2);
	ov_memstack_unlock();
    return factory;
}

OV_RESULT crawl_tree(const OV_INSTPTR_ov_domain pobj,  cJSON* jsobj, cJSON* jslibs, OV_BOOL getvariables){
	OV_RESULT res = 0;

	cJSON* current = NULL;

	//variables
	if(getvariables){
		current = cJSON_AddObjectToObject(jsobj, "variables");
//		get_variables(pobj, current);
	}
	//factory
	OV_STRING factory = get_factory(pobj);
	cJSON_AddStringToObject(jsobj, "factory", factory);
	ov_logfile_debug("%s \n", factory);

	//libraries
	OV_UINT len=0;
	OV_STRING* seperated = ov_string_split(factory, "/", &len);
	if(seperated == NULL)
		return OV_ERR_BADVALUE;

	if(len!=4)
		return OV_ERR_BADVALUE;

	current = cJSON_GetArrayItem(jslibs, seperated[2]);
	if(current==NULL)
		cJSON_AddStringToObject(jslibs, seperated[2], seperated[2]);

	//children
	cJSON* jschildren = cJSON_AddObjectToObject(pobj, "children");
	OV_INSTPTR_ov_domain pchild = NULL;

	Ov_ForEachChild(ov_containment, pobj, pchild){
		cJSON* jschild = cJSON_AddObjectToObject(jschildren, pchild->v_identifier);
		res = crawl_tree(pchild, jschild, jslibs, getvariables);
		if(Ov_Fail(res))
			return res;
	}
	return res;
}
