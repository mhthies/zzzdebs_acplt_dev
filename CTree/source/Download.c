/******************************************************************************
 *
 *   FILE
 *   ----
 *   Download.c
 *
 *   History
 *   -------
 *   2018-02-27   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/

#define OV_DEBUG

#ifndef OV_COMPILE_LIBRARY_CTree
#define OV_COMPILE_LIBRARY_CTree
#endif

#include "CTree.h"
#include "libov/ov_macros.h"
#include "libov/ov_string.h"
#include "libov/ov_library.h"
#include "libov/ov_path.h"
#include "libov/ov_element.h"
#include "libov/ov_result.h"
#include "libov/ov_object.h"
#include "libov/ov_variable.h"

#include "ksbase.h"
#include "NoneTicketAuthenticator.h"

#include "cJSON.h"

#include "libov/ov_debug.h"

#include <stdarg.h>
#include <string.h>
#include <stdio.h>

#define VERSION_FOR_CTREE 	2

static char			msg[1024];

OV_RESULT crawl_tree(OV_INSTPTR_CTree_Download pinst,
		const OV_INSTPTR_ov_domain pobj, cJSON* jsobj);

OV_RESULT get_variables(const OV_INSTPTR_ov_object pobj, cJSON* jsvars,
		OV_ELEM_TYPE mask);

OV_RESULT crawl_links(cJSON* jslibs, const OV_ELEMENT* pelobj);

OV_RESULT write_link(cJSON* jslinks, OV_ELEMENT* pelassoc, OV_ELEM_TYPE mask);

//checks if variable is one of the variables of ov_object
OV_RESULT is_standard_variable(OV_STRING identifier);

/*
OV_RESULT CTree_log(OV_INSTPTR_CTree_Upload pinst, OV_MSG_TYPE msg_type,
		const OV_STRING format, ...) {
	OV_RESULT res = OV_ERR_OK;
	va_list args;

	ov_string_print(&pinst->v_log, format, args);
	if (msg_type == OV_MT_ERROR)
		ov_string_print(&pinst->v_errorLog, format, args);


	 	print text to logfile

	va_start(args, format);
#if OV_SYSTEM_UNIX && !OV_SYSTEM_SOLARIS
	vsnprintf(pinst->v_cache.msg, sizeof(pinst->v_cache.msg), format, args);
#else
	vsprintf(pinst->v_cache.msg, format, args);
#endif
	va_end(args);
	ov_logfile_print(msg_type, pinst->v_cache.msg);
	return res;
}

*/

OV_RESULT Download_log_exit(OV_INSTPTR_CTree_Download pinst, OV_MSG_TYPE msg_type, OV_RESULT result,
		 const OV_STRING format, ...) {
	cJSON_free(pinst->v_cache.jsbase);
	va_list args;

	char msg[1024];
	pinst->v_result = result;
	va_start(args, format);

#if OV_SYSTEM_UNIX && !OV_SYSTEM_SOLARIS
	vsnprintf(msg, sizeof(msg), format, args);
#else
	vsprintf(msg, format, args);
#endif
	va_end(args);

	ov_logfile_print(msg_type, msg);

	ov_string_append(&pinst->v_log, msg);
	ov_string_append(&pinst->v_log, "\n");
	ov_string_append(&pinst->v_log, ov_result_getresulttext(result));
	ov_string_append(&pinst->v_log, "\n");

	ov_string_append(&pinst->v_errorLog, ov_result_getresulttext(result));
	ov_string_append(&pinst->v_errorLog, "\n");
	ov_string_append(&pinst->v_errorLog, msg);
	ov_string_append(&pinst->v_errorLog, "\n");

	return result;
}

OV_DLLFNCEXPORT void CTree_Download_submit(OV_INSTPTR_CTree_CTreeCommon pobj) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_CTree_Download pinst = Ov_StaticPtrCast(CTree_Download, pobj);
	OV_INSTPTR_ov_domain proot = NULL;

	OV_RESULT res = 0;

	//init
	pinst->v_cache.jsbase = cJSON_CreateObject();
	pinst->v_cache.jslibs = cJSON_AddArrayToObject(pinst->v_cache.jsbase,
			"Libraries");
	pinst->v_cache.jstree = cJSON_AddObjectToObject(pinst->v_cache.jsbase,
			"Tree");
	pinst->v_cache.jslinks = cJSON_AddArrayToObject(pinst->v_cache.jsbase,
			"Links");
	cJSON_AddStringToObject(pinst->v_cache.jsbase, "Path", pinst->v_root);

	pinst->v_cache.proot = Ov_StaticPtrCast(ov_domain,
			ov_path_getobjectpointer(pinst->v_root, VERSION_FOR_CTREE));

	//!!!check if root is accessable
	if (pinst->v_cache.proot == NULL) {
		Download_log_exit(pinst, OV_MT_ERROR, OV_ERR_BADPARAM,
				"%s could not be found", pinst->v_root);
		return;
	}

	OV_INSTPTR_ov_domain pchild = NULL;

/*
	crawling
*/
	cJSON* jsroot = cJSON_AddObjectToObject(pinst->v_cache.jstree, pinst->v_root);
	res = crawl_tree(pinst, pinst->v_cache.proot, jsroot);
	if (Ov_Fail(res)) {
		Download_log_exit(pinst, OV_MT_ERROR, res,
				"%s could not be found", pinst->v_root);
		return;
	}
	/*Ov_ForEachChild(ov_containment, pinst->v_cache.proot, pchild)
	{
		cJSON* jschild = cJSON_AddObjectToObject(pinst->v_cache.jstree,
				pchild->v_identifier);
		res = crawl_tree(pinst, pchild, jschild);
		if (Ov_Fail(res)) {
			Download_log_exit(pinst, res, ov_logfile_error,
					"%s could not be found", pinst->v_root);
			return;
		}
	}*/

	//checking libs and tree

	//links
	OV_ELEMENT elroot;
	elroot.elemtype = OV_ET_OBJECT;
	elroot.pobj = proot;

	res = crawl_links(pinst->v_cache.jslinks, &elroot);
	if (Ov_Fail(res)) {
		pinst->v_result = res;
		cJSON_free(pinst->v_cache.jsbase);
		return;
	}

	res = ov_string_setvalue(&pinst->v_tree,
			cJSON_Print(pinst->v_cache.jsbase));
	if (Ov_Fail(res)) {
		pinst->v_result = res;
		cJSON_free(pinst->v_cache.jsbase);
		return;
	}
	res = ov_string_setvalue(&pinst->v_libs,
			cJSON_Print(pinst->v_cache.jslibs));
	if (Ov_Fail(res)) {
		pinst->v_result = res;
		cJSON_free(pinst->v_cache.jsbase);
		return;
	}
	cJSON_free(pinst->v_cache.jsbase);
	return;
}

OV_RESULT crawl_links(cJSON* jslinks, const OV_ELEMENT* pelobj) {

	OV_RESULT res = OV_ERR_OK;

//	get_links(jslinks, pelobj, OV_ET_PARENTLINK);
	get_links(jslinks, pelobj, OV_ET_CHILDLINK);

	OV_ELEMENT elchild;
	elchild.elemtype = OV_ET_NONE;

	ov_element_getnextchild(pelobj, &elchild);
	while (elchild.elemtype == OV_ET_OBJECT) {

		res = crawl_links(jslinks, &elchild);
		if (Ov_Fail(res))
			return res;
		ov_element_getnextchild(pelobj, &elchild);
	}
	return res;
}

OV_RESULT get_links(cJSON* jslinks, OV_ELEMENT* pelobj, OV_ELEM_TYPE mask) {
	OV_RESULT res = OV_ERR_OK;

	OV_ELEMENT elvar;
	elvar.elemtype = OV_ET_NONE;

	while (TRUE) {
		//get links
		res = ov_element_getnextpart(pelobj, &elvar, mask);
		if (Ov_Fail(res)) {
			ov_logfile_error("%s", ov_result_getresulttext(res));
			return res;
		}
		if (elvar.elemtype == OV_ET_NONE)
			break;

		res = write_link(jslinks, &elvar, mask);
		if (res == OV_ERR_OPTYPEDEFMISMATCH) {
			res = OV_ERR_OK;
		}
	}
	return res;
}

OV_RESULT write_link(cJSON* jslinks, OV_ELEMENT* pelassoc, OV_ELEM_TYPE mask) {
	OV_RESULT res = OV_ERR_OK;

	OV_INSTPTR_ov_association passoc = pelassoc->elemunion.passoc;

	cJSON* jsparent = NULL;
	cJSON* jschild = NULL;
	cJSON* current = cJSON_CreateObject();

	OV_INSTPTR_ov_object pparent = NULL;
	OV_INSTPTR_ov_object pchild = NULL;

	//of_association
	ov_memstack_lock();
	OV_STRING factory = ov_path_getcanonicalpath(
			Ov_PtrUpCast(ov_object, passoc), VERSION_FOR_CTREE);
	ov_memstack_unlock();
	if (ov_string_match(factory, "*/ov/containment")
			|| ov_string_match(factory, "*/ov/instantiation"))
		return OV_ERR_OPTYPEDEFMISMATCH;

	cJSON_AddStringToObject(current, "of_association", factory);
	cJSON_AddItemToArray(jslinks, current);

	jsparent = cJSON_AddArrayToObject(current, "parents");
//	cJSON_AddItemToArray(jsparent, cJSON_CreateString(passoc->v_parentrolename));

	jschild = cJSON_AddArrayToObject(current, "children");
//	cJSON_AddItemToArray(jschild, cJSON_CreateString(passoc->v_childrolename));

	switch (passoc->v_assoctype) {
	case OV_AT_ONE_TO_MANY:
//		switch (mask) {
//		case OV_ET_CHILDLINK:
		pparent = Ov_Association_GetParent(passoc, pelassoc->pobj);
		ov_memstack_lock();
		factory = ov_path_getcanonicalpath(pparent,
		VERSION_FOR_CTREE);
		ov_memstack_unlock();

//			OV_STRING match=NULL;
//			ov_string_setvalue(&match, "");
//			ov_string_append(&match, "*");
		//TODO:
//			if (ov_string_match(factory, "/TechUnits/*"))
//					break;
		cJSON_AddItemToArray(jsparent, cJSON_CreateString(factory));

		ov_memstack_lock();
		factory = ov_path_getcanonicalpath(pelassoc->pobj,
		VERSION_FOR_CTREE);
		cJSON_AddItemToArray(jschild, cJSON_CreateString(factory));
		ov_memstack_unlock();
		break;
//		case OV_ET_PARENTLINK:
//			ov_memstack_lock();
//			factory = ov_path_getcanonicalpath(pelassoc->pobj,
//			VERSION_FOR_CTREE);
//			ov_memstack_unlock();
//			cJSON_AddItemToArray(jsparent, cJSON_CreateString(factory));

		Ov_Association_ForEachChild(passoc, pparent, pchild)
		{
			ov_memstack_lock();
			OV_STRING factory = ov_path_getcanonicalpath(pchild,
			VERSION_FOR_CTREE);
			cJSON_AddItemToArray(jschild, cJSON_CreateString(factory));
			ov_memstack_unlock();
		}
//		}
		break;
	case OV_AT_MANY_TO_MANY:
		Ov_Error("many to many")
		;
		break;
	case OV_AT_ONE_TO_ONE:
		Ov_Error("one to one")
		;
		break;
	}

	return res;
}

OV_RESULT get_ep(OV_INSTPTR_CTree_Download pinst, cJSON* jsobj,
		const OV_STRING object_path) {

	OV_GETEP_PAR params;
	OV_GETEP_RES result;
	OV_OBJ_ENGINEERED_PROPS *one_result;

	OV_TICKET* pticket = NULL;

	OV_RESULT res = OV_ERR_OK;

	cJSON* jschild = NULL;
	OV_STRING mask = NULL;
	OV_STRING accessstr = NULL;
	OV_STRING var_path = NULL;

	//initialize ov_string
	params.path = NULL;
	params.name_mask = NULL;

	cJSON* jsvars = cJSON_AddObjectToObject(jsobj, "variables");
//	cJSON* jschildren = cJSON_AddObjectToObject(jsobj, "children");

	/**
	 * Build Parameter for KS function
	 */
	//TODO: check input
	//path
	ov_string_setvalue(&params.path, object_path);

	//mask
	if (mask) {
		ov_string_setvalue(&params.name_mask, mask);
	} else {
		ov_string_setvalue(&params.name_mask, "*");
	}

	//flag
//	KS_EP_FLAGS flag;
//	if (flag) {
//		params.scope_flags = flag;
//	} else {
		params.scope_flags = KS_EPF_DEFAULT;
//	}

//	KS_OBJ_TYPE object_type = KS_OT_VARIABLE;
//	if (object_type) {
//		params.type_mask = object_type;
//	} else {
//		res = OV_ERR_BADPARAM;
////					": Requesttype not supported");
//		return res;
//	}
	params.type_mask = KS_OT_ANY;

	//create NONE-ticket
	pticket = ksbase_NoneAuth->v_ticket.vtbl->createticket(NULL, OV_TT_NONE);

	ov_memstack_lock(); //needed for ov_path_resolve and the class_identifier
	ov_ksserver_getep(2, pticket, &params, &result);

	if (Ov_Fail(result.result)) {
		//getEP is only valid for one target, so this variable hold all possible errors, not only NOACCESS like the other services
		ov_memstack_unlock();
//		return Download_print_log_exit(pinst, result.result);
		return result.result;
	}

	one_result = result.pfirst;
	while (one_result != NULL) {
		//open Child item level
		if (result.pfirst != one_result) {
//		kshttp_response_parts_seperate(&temp, request.response_format);
		}
		//change target output
		switch (one_result->objtype) {
		case KS_OT_DOMAIN:
			/*
			jschild = cJSON_AddObjectToObject(jschildren, one_result->);
			res = crawl_tree(pinst, Ov_StaticPtrCast(ov_domain, elchild.pobj),
					jschild);
			if (Ov_Fail(res))
				return res;
			*/
			break;
		case KS_OT_LINK:
			break;
		case KS_OT_VARIABLE:
			jschild = cJSON_AddArrayToObject(jsvars, one_result->identifier);

/*
 * 			Accessing information
			CTree_helper_accessToStr(&accessstr, &one_result->access);
			cJSON_AddItemToArray(jschild,
					cJSON_CreateString(accessstr));
*/

			OV_GETVAR_RES get_var_res = {0, 0, NULL};

			ov_string_setvalue(&var_path, object_path);
			ov_string_append(&var_path, ".");
			ov_string_append(&var_path, one_result->identifier);
			OV_GETVAR_PAR get_var_par = {.identifiers_len=1, .identifiers_val=&var_path};
			ov_ksserver_getvar(VERSION_FOR_CTREE, pticket, &get_var_par, &get_var_res);

/*
			getting type as string
*/
			OV_STRING typestr;
			//			ov_string_setvalue(&typestr, "1");
			res = CTree_helper_ovtypeToStr(&typestr, &get_var_res.items_val[0].var_current_props.value.vartype);
			if (Ov_OK(res)) {
				cJSON_AddItemToArray(jschild, cJSON_CreateString(typestr));
			} else {
				cJSON_AddItemToArray(jschild, cJSON_CreateString("error"));
			}
			OV_STRING valuestr = "";
/*
			getting value as string
*/
			res = CTree_helper_valueToStr(&valuestr, &get_var_res.items_val[0].var_current_props.value);
			if (Ov_OK(res)) {
				if(valuestr==NULL){
/*
					does not save empty value
*/
					cJSON_DeleteItemFromObject(jsvars, one_result->identifier);
					break;
				};
				cJSON_AddItemToArray(jschild, cJSON_CreateString(valuestr));
			} else {
				cJSON_AddItemToArray(jschild, cJSON_CreateString("error"));
			}

			break;
		case OV_OT_HISTORY:
			break;
		case OV_OT_STRUCTURE:
			break;
		case OV_OT_ANY:
			break;
		default:
			break;
		}

		if (Ov_Fail(res)) {
//		//should not happen with an UINT
//		ov_string_append(&response->contentString, "internal memory problem");
//		res = OV_ERR_GENERIC;
//		kshttp_print_result_array(&message, request.response_format, &res, 1,
//				": internal memory problem");
			return res; //503
		}

		one_result = one_result->pnext;
	}
	ov_memstack_unlock();
	/*	delete Ticket	*/
	pticket->vtbl->deleteticket(pticket);

	return res;
}

OV_RESULT get_variables(const OV_INSTPTR_ov_object pobj, cJSON* jsvars,
		OV_ELEM_TYPE mask) {
	OV_RESULT res = OV_ERR_OK;

	OV_INSTPTR_ov_object pchild;
	OV_STRING identifier = NULL;

	OV_ELEMENT elparent;
	elparent.elemtype = OV_ET_OBJECT;
	elparent.pobj = pobj;

	OV_VTBLPTR_ov_object pVtblObj = NULL;

	OV_ELEMENT elvar;
	elvar.elemtype = OV_ET_NONE;

	OV_ANY value;
	cJSON* jschild = NULL;

	Ov_GetVTablePtr(ov_object, pVtblObj, pobj);
	while (TRUE) {
		//get variable element
		res = ov_element_getnextpart(&elparent, &elvar, mask);
		if (Ov_Fail(res)) {
			ov_logfile_error("%s", ov_result_getresulttext(res));
			return res;
		}
		if (elvar.elemtype == OV_ET_NONE)
			break;

		if (elvar.elemtype == mask)
			res = pVtblObj->m_getvar(elvar.pobj, &elvar, &value);

		switch (mask) {
		case OV_ET_NONE:/* invalid element */
		case OV_ET_OBJECT:
		case OV_ET_MEMBER: /* structure member (superseded by PART) */
		case OV_ET_OPERATION:
		case OV_ET_ANY:
			ov_logfile_info("Cannot handle it for now");
			break;
		case OV_ET_VARIABLE:

			ov_string_setvalue(&identifier, ov_element_getidentifier(&elvar));
			if (is_standard_variable(identifier))
				break;

			jschild = cJSON_AddArrayToObject(jsvars, identifier);
//			ov_variable_initialvalue_get();
			// access = pVtblObj->m_getaccess(pobj, pelem, pticket);
			cJSON_AddItemToArray(jschild, cJSON_CreateString("1"));
			OV_STRING valuestr = "";
//			ov_string_setvalue(&valuestr, "1");
			res = CTree_helper_valueToStr(&valuestr, &value.value);
			if (Ov_OK(res)) {
				cJSON_AddItemToArray(jschild, cJSON_CreateString(valuestr));
			} else {
				cJSON_AddItemToArray(jschild, cJSON_CreateString("error"));
			}

			OV_STRING typestr;
//			ov_string_setvalue(&typestr, "1");
			res = CTree_helper_ovtypeToStr(&typestr, &value.value.vartype);
			if (Ov_OK(res)) {
				cJSON_AddItemToArray(jschild, cJSON_CreateString(typestr));
			} else {
				cJSON_AddItemToArray(jschild, cJSON_CreateString("error"));
			}
			break;
		case OV_ET_PARENTLINK:
			jschild = cJSON_AddArrayToObject(jsvars,
					ov_element_getidentifier(&elvar));

			cJSON_AddItemToArray(jschild, cJSON_CreateString("parentlink"));

			cJSON_AddItemToArray(jschild,
					cJSON_CreateString(
							elvar.elemunion.passoc->v_parentrolename));
			cJSON_AddItemToArray(jschild,
					cJSON_CreateString(
							elvar.elemunion.passoc->v_childrolename));

			ov_memstack_lock();
			cJSON_AddItemToArray(jschild,
					cJSON_CreateString(
							ov_path_getcanonicalpath(
									Ov_PtrUpCast(ov_object,
											elvar.elemunion.passoc),
									VERSION_FOR_CTREE)));
			ov_memstack_unlock();
			break;
		case OV_ET_CHILDLINK:
			jschild = cJSON_AddArrayToObject(jsvars,
					ov_element_getidentifier(&elvar));

			cJSON_AddItemToArray(jschild, cJSON_CreateString("childlink"));

			cJSON_AddItemToArray(jschild,
					cJSON_CreateString(
							elvar.elemunion.passoc->v_parentrolename));
			cJSON_AddItemToArray(jschild,
					cJSON_CreateString(
							elvar.elemunion.passoc->v_childrolename));

			ov_memstack_lock();
			cJSON_AddItemToArray(jschild,
					cJSON_CreateString(
							ov_path_getcanonicalpath(
									Ov_PtrUpCast(ov_object,
											elvar.elemunion.passoc),
									VERSION_FOR_CTREE)));
			ov_memstack_unlock();
		}
	}

	return res;
}

OV_RESULT crawl_tree(OV_INSTPTR_CTree_Download pinst,
		const OV_INSTPTR_ov_domain pobj, cJSON* jsobj) {
	cJSON* jslibs = pinst->v_cache.jslibs;
	OV_RESULT res = 0;

	cJSON* current = NULL;

	//debug
	ov_memstack_lock();

/*
    variables
*/
	if (pinst->v_getvar) {
//		current = cJSON_AddObjectToObject(jsobj, "variables");
//		get_variables(Ov_PtrUpCast(ov_object, pobj), current, OV_ET_VARIABLE);
		get_ep(pinst, jsobj, ov_path_getcanonicalpath(Ov_PtrUpCast(ov_object, pobj), VERSION_FOR_CTREE));
	}
	ov_memstack_unlock();


//factory
	OV_STRING factory = CTree_helper_getfactory(pobj);
	cJSON_AddStringToObject(jsobj, "factory", factory);

//	libraries
	OV_UINT len = 0;
	OV_STRING* seperated = ov_string_split(factory, "/", &len);
	if (seperated == NULL)
		return OV_ERR_BADVALUE;

	if (len < 2)
		return OV_ERR_BADVALUE;

//	checks if the library already found.
	current = cJSON_GetObjectItem(jslibs, seperated[len - 2]);
	if (current == NULL)
		cJSON_AddStringToObject(jslibs, seperated[len - 2], seperated[len - 2]);
/*
	variables & children & links
*/
//	get_ep(pinst, jsobj, ov_path_getcanonicalpath(Ov_PtrUpCast(ov_object, pobj), VERSION_FOR_CTREE));


/*
	children
*/
	cJSON* jschildren = cJSON_AddObjectToObject(jsobj, "children");

	OV_ELEMENT objElement;
	objElement.elemtype = OV_ET_OBJECT;
	objElement.pobj = Ov_PtrUpCast(ov_object, pobj);

	OV_ELEMENT elchild;
	elchild.elemtype = OV_ET_NONE;
	ov_element_getnextchild(&objElement, &elchild);
	while (elchild.elemtype == OV_ET_OBJECT) {
		ov_logfile_info("%s", ov_element_getidentifier(&elchild));

		cJSON* jschild = cJSON_AddObjectToObject(jschildren,
				ov_element_getidentifier(&elchild));
		res = crawl_tree(pinst, Ov_StaticPtrCast(ov_domain, elchild.pobj),
				jschild);
		if (Ov_Fail(res))
			return res;
		ov_element_getnextchild(&objElement, &elchild);
	}


	return res;
}

OV_RESULT is_standard_variable(OV_STRING identifier) {
	return !ov_string_compare(identifier, "identifier")
			|| !ov_string_compare(identifier, "creationtime")\

			|| !ov_string_compare(identifier, "pouterobject")\

			|| !ov_string_compare(identifier, "objectstate")\

			|| !ov_string_compare(identifier, "linktable");
}
