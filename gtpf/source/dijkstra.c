/******************************************************************************
 *
 *   FILE
 *   ----
 *   dijkstra.c
 *
 *   History
 *   -------
 *   2018-07-16   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/

#ifndef OV_COMPILE_LIBRARY_gtpf
#define OV_COMPILE_LIBRARY_gtpf
#endif

#include "gtpf.h"
#include "libov/ov_macros.h"
#include "CException.h"
#include "TGraph.h"
#include "dijkstra.h"

OV_DLLFNCEXPORT OV_RESULT gtpf_dijkstra_EN_set(OV_INSTPTR_gtpf_dijkstra pobj,
		const OV_UINT value) {
	pobj->v_EN = value;
	OV_TIME pltc;

	switch (value) {
		case 1:
			ov_time_gettime(&pltc);
			gtpf_dijkstra_typemethod(Ov_StaticPtrCast(fb_functionblock, pobj), &pltc);
			break;
		case 3:
			Ov_SetDynamicVectorLength(&pobj->v_pathNode, 0, STRING);
			Ov_SetDynamicVectorLength(&pobj->v_pathDir, 0, STRING);
			pobj->v_result = 0;
			break;
		default:
			break;
	}
	pobj->v_EN = 0;
	return OV_ERR_OK;
}

//OV_RESULT gtpf_dijkstra_execute(OV_INSTPTR_gtpf_dijkstra pinst) {
//	OV_INSTPTR_TGraph_graph pgraph = ov_path_getobjectpointer(pinst->v_topologie,
//		2);
//	// param check
//	if(!pgraph) {
//		ov_logfile_error("topology could not be found");
//		return OV_ERR_BADPARAM;
//	}
//
//	OV_RESULT result = OV_ERR_OK;
//	OV_INSTPTR_TGraph_Node* recipes = NULL;
//
//	// get start
//	OV_STRING pathStr = NULL;
//	ov_string_print(&pathStr, "%s/%s", pinst->v_topologie, pinst->v_start);
//	OV_INSTPTR_TGraph_Node proot = ov_path_getobjectpointer(pathStr, 2);
//	// param check
//	if(!proot) {
//		ov_logfile_error("start object could not be found");
//		return OV_ERR_BADPARAM;
//	}
//
//	// get recipes
//	OV_UINT numberOfStations = 1 + pinst->v_recipe.veclen;
//	recipes = ov_memstack_alloc(
//		numberOfStations * sizeof(OV_INSTPTR_TGraph_Node));
//	for (OV_UINT i = 0; i < pinst->v_recipe.veclen; ++i) {
//		ov_string_print(&pathStr, "%s/%s", pinst->v_topologie,
//			pinst->v_recipe.value[i]);
//		result = initDataFromStr(&recipes[i + 1], pathStr);
//		// check
//		if(Ov_Fail(result)) {
//			return result;
//		}
//	}
//	ov_string_setvalue(&pathStr, NULL);
//
//	// bfs
//	OV_UINT pathLengthSum = 0;
//	Data_t from;
//	from = recipes[0];
//
//	for (OV_UINT i = 1; i < numberOfStations; ++i) {
//		// list
//		list_t *path = constructList(sizeof(Data_t));
//		path->printNode = &printData;
//		result = BFS(path, &from, &recipes[i]);
//		if(Ov_Fail(result)) {
//			ov_logfile_error("No path found from %s to %s", from.self->v_identifier,
//				recipes[i].self->v_identifier);
//			//free
//			Ov_HeapFree(recipes);
//			destructList(path);
//			return result;
//		}
//		OV_INSTPTR_TGraph_Node psource = OV_INSTPTR_TGraph_Node
//		ptarget
//		dijkstra_get_path( pgraph,);
//	}
//}

OV_DLLFNCEXPORT void gtpf_dijkstra_typemethod(OV_INSTPTR_fb_functionblock pfb,
		OV_TIME *pltc) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_gtpf_dijkstra pinst = Ov_StaticPtrCast(gtpf_dijkstra, pfb);
	OV_RESULT result = OV_ERR_OK;
	result = gtpf_dijkstra_execute(pinst);
	switch (result) {
		case OV_ERR_OK:
			ov_logfile_info("dijkstra: done");
			pinst->v_result = result;
			break;
		case OV_ERR_BADPARAM:
			ov_logfile_error("dijkstra: bad param");
			pinst->v_result = result;
			break;
		default:
			ov_logfile_error("dijkstra: failed \n error: %s",
				ov_result_getresulttext(result));
			pinst->v_result = 1;
	}

	return;
}

