/******************************************************************************
 *
 *   FILE
 *   ----
 *   bfs.c
 *
 *   History
 *   -------
 *   2018-05-18   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/

#ifndef OV_COMPILE_LIBRARY_graphSearch
#define OV_COMPILE_LIBRARY_graphSearch
#endif

#include <string.h>
#include <search.h>

#include "list.h"
#include "graphSearch.h"
#include "SMSTopologie.h"
#include "libov/ov_macros.h"
#include "libov/ov_path.h"
#include "libov/ov_result.h"
#include "smscrmlogistic.h"


enum Level { LEVEL0, LEVEL1 };
enum Direction { UP, RIGHT, DOWN, LEFT, MAXCHILDNUM };
enum Nodetype { ROLLER, SCHIEBER };


typedef struct Node {
  OV_INSTPTR_ov_object self;
  enum Nodetype type;
  enum Level position;

  struct Node *pparent;
  enum Direction parentdirection;

  OV_INT depth;
} Node_t;

void printNode(struct listNode* node){
	ov_logfile_info("%d, %d, %d", ((Node_t*)node->data)->type,
	((Node_t*)node->data)->parentdirection,
	((Node_t*)node->data)->position);
}

int compareNodes(struct listNode* node1, struct listNode* node2){
	return !is_same((Node_t*)node1->data, (Node_t*)node2->data);
}


//OV_RESULT get_children(Node_t *parent, Node_t *children[0],
//                       OV_UINT *numberOfChildren) {
//  OV_INSTPTR_SMSTopologie_Rollgang pparentRG = NULL;
//  OV_INSTPTR_SMSTopologie_Schieber pparentS = NULL;
//
//  OV_UINT numOfCreatedChildren = 0;
//  Node_t* childrenArray = NULL;
//
//  Node_t *childNode = ov_memstack_alloc(sizeof(Node_t));
//
//  switch (parent->type) {
//  case ROLLER:
//    pparentRG = Ov_StaticPtrCast(SMSTopologie_Rollgang, parent->self);
//    break;
//  case SCHIEBER:
//    pparentS = Ov_StaticPtrCast(SMSTopologie_Schieber, parent->self);
//    break;
//  default:
//    return 1;
//  }
//  // check validity
//  if (parent->position) {
//    childNode;
//  }
//
//  for (OV_UINT dir = 0; dir < MAXCHILDNUM; ++dir) {
//    childNode->depth = parent->depth + 1;
//    childNode->parentdirection = dir;
//    childNode->position = parent->position;
//    childNode->pparent = parent;
//    childNode->self = NULL;
//
//    switch (parent->type) {
//    case ROLLER:
//      pparentRG = Ov_StaticPtrCast(SMSTopologie_Rollgang, parent->self);
//      switch (dir) {
//      case RIGHT:
//        // if roller
//        childNode->type = ROLLER;
//        childNode->self = Ov_StaticPtrCast(
//            ov_object, Ov_GetChild(SMSTopologie_RG, pparentRG));
//        if (childNode->self)
//          break;
//        // if schieber
//        childNode->type = SCHIEBER;
//
//        childNode->self = Ov_StaticPtrCast(
//            ov_object, Ov_GetParent(SMSTopologie_SchieberUntenR, pparentRG));
//        childNode->position = LEVEL0;
//        if (childNode->self)
//          break;
//        childNode->self = Ov_StaticPtrCast(
//            ov_object, Ov_GetParent(SMSTopologie_SchieberObenR, pparentRG));
//        childNode->position = LEVEL1;
//        if (childNode->self)
//          break;
//        break;
//      case LEFT:
//        childNode->type = ROLLER;
//        childNode->self = Ov_StaticPtrCast(
//            ov_object, Ov_GetParent(SMSTopologie_RG, pparentRG));
//        if (childNode->self)
//          break;
//        // if schieber
//        childNode->type = SCHIEBER;
//
//        childNode->self = Ov_StaticPtrCast(
//            ov_object, Ov_GetParent(SMSTopologie_SchieberUntenL, pparentRG));
//        childNode->position = LEVEL0;
//        if (childNode->self)
//          break;
//        childNode->self = Ov_StaticPtrCast(
//            ov_object, Ov_GetParent(SMSTopologie_SchieberObenL, pparentRG));
//        childNode->position = LEVEL1;
//        if (childNode->self)
//          break;
//        break;
//      }
//      break;
//
//    case SCHIEBER:
//      pparentS = Ov_StaticPtrCast(SMSTopologie_Schieber, parent->self);
//      childNode->type = ROLLER;
//      switch (parent->position) {
//      case LEVEL0:
//        switch (dir) {
//        case UP:
//          childNode->self = parent->self;
//          childNode->position = LEVEL1;
//          break;
//        case RIGHT:
//          childNode->self = Ov_StaticPtrCast(
//              ov_object, Ov_GetChild(SMSTopologie_SchieberUntenL, pparentS));
//          break;
//        case DOWN:
//          break;
//        case LEFT:
//          childNode->self = Ov_StaticPtrCast(
//              ov_object, Ov_GetChild(SMSTopologie_SchieberUntenR, pparentS));
//          break;
//        }
//        break;
//      case LEVEL1:
//        switch (dir) {
//        case UP:
//          break;
//        case RIGHT:
//          childNode->self = Ov_StaticPtrCast(
//              ov_object, Ov_GetChild(SMSTopologie_SchieberObenL, pparentS));
//          break;
//        case DOWN:
//          childNode->self = parent->self;
//          childNode->position = LEVEL0;
//          break;
//        case LEFT:
//          childNode->self = Ov_StaticPtrCast(
//              ov_object, Ov_GetChild(SMSTopologie_SchieberObenR, pparentS));
//          break;
//        }
//        break;
//      }
//      break;
//    }
//    // adding child if ok
//    if (childNode->self) {
//    	if(!childrenArray){
//    		numOfCreatedChildren++;
//    		childrenArray = Ov_HeapMalloc(sizeof(Node_t));
//    	} else {
//    		Ov_HeapRealloc(childrenArray,
//                     sizeof(Node_t) * (++numOfCreatedChildren));
//    	}
//    	childrenArray[numOfCreatedChildren - 1] = *childNode;
//    	childrenArray[numOfCreatedChildren - 1].self = childNode->self;
//    }
//  }
//  *children = childrenArray;
//  *numberOfChildren = numOfCreatedChildren;
//  return 0;
//}

OV_RESULT get_children(Node_t *parent, Node_t *children[0],
                       OV_UINT *numberOfChildren) {
  OV_INSTPTR_SMSTopologie_Rollgang pparentRG = NULL;
  OV_INSTPTR_SMSTopologie_Schieber pparentS = NULL;

  OV_UINT numOfCreatedChildren = 0;
  Node_t* childrenArray = NULL;

  Node_t *childNode = ov_memstack_alloc(sizeof(Node_t));

  switch (parent->type) {
  case ROLLER:
    pparentRG = Ov_StaticPtrCast(SMSTopologie_Rollgang, parent->self);
    break;
  case SCHIEBER:
    pparentS = Ov_StaticPtrCast(SMSTopologie_Schieber, parent->self);
    break;
  default:
    return 1;
  }
  // check validity
  if (parent->position) {
    childNode;
  }

  for (OV_UINT dir = 0; dir < MAXCHILDNUM; ++dir) {
    childNode->depth = parent->depth + 1;
    childNode->parentdirection = dir;
    childNode->position = parent->position;
    childNode->pparent = parent;
    childNode->self = NULL;

    switch (parent->type) {
    case ROLLER:
      pparentRG = Ov_StaticPtrCast(SMSTopologie_Rollgang, parent->self);
      switch (dir) {
      case RIGHT:
        // if roller
        childNode->type = ROLLER;
        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetChild(SMSTopologie_RG, pparentRG));
        if (childNode->self)
          break;
        // if schieber
        childNode->type = SCHIEBER;

        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetParent(SMSTopologie_SchieberUntenR, pparentRG));
        childNode->position = LEVEL0;
        if (childNode->self)
          break;
        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetParent(SMSTopologie_SchieberObenR, pparentRG));
        childNode->position = LEVEL1;
        if (childNode->self)
          break;
        break;
      case LEFT:
        childNode->type = ROLLER;
        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetParent(SMSTopologie_RG, pparentRG));
        if (childNode->self)
          break;
        // if schieber
        childNode->type = SCHIEBER;

        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetParent(SMSTopologie_SchieberUntenL, pparentRG));
        childNode->position = LEVEL0;
        if (childNode->self)
          break;
        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetParent(SMSTopologie_SchieberObenL, pparentRG));
        childNode->position = LEVEL1;
        if (childNode->self)
          break;
        break;
      }
      break;

    case SCHIEBER:
      pparentS = Ov_StaticPtrCast(SMSTopologie_Schieber, parent->self);
      childNode->type = ROLLER;
      switch (parent->position) {
      case LEVEL0:
        switch (dir) {
        case UP:
          childNode->self = parent->self;
          childNode->position = LEVEL1;
          break;
        case RIGHT:
          childNode->self = Ov_StaticPtrCast(
              ov_object, Ov_GetChild(SMSTopologie_SchieberUntenL, pparentS));
          break;
        case DOWN:
          break;
        case LEFT:
          childNode->self = Ov_StaticPtrCast(
              ov_object, Ov_GetChild(SMSTopologie_SchieberUntenR, pparentS));
          break;
        }
        break;
      case LEVEL1:
        switch (dir) {
        case UP:
          break;
        case RIGHT:
          childNode->self = Ov_StaticPtrCast(
              ov_object, Ov_GetChild(SMSTopologie_SchieberObenL, pparentS));
          break;
        case DOWN:
          childNode->self = parent->self;
          childNode->position = LEVEL0;
          break;
        case LEFT:
          childNode->self = Ov_StaticPtrCast(
              ov_object, Ov_GetChild(SMSTopologie_SchieberObenR, pparentS));
          break;
        }
        break;
      }
      break;
    }
    // adding child if ok
    if (childNode->self) {
    	if(!childrenArray){
    		numOfCreatedChildren++;
    		childrenArray = Ov_HeapMalloc(sizeof(Node_t));
    	} else {
    		Ov_HeapRealloc(childrenArray,
                     sizeof(Node_t) * (++numOfCreatedChildren));
    	}
    	childrenArray[numOfCreatedChildren - 1] = *childNode;
    	childrenArray[numOfCreatedChildren - 1].self = childNode->self;
    }
  }
  *children = childrenArray;
  *numberOfChildren = numOfCreatedChildren;
  return 0;
}

OV_INT is_same(Node_t* r1, Node_t* r2){
	if(r1->self!=r2->self && r1->type != r2->type);
		return 0;
	if(r1->type==SCHIEBER)
		if(r1->position!=r2->position)
			return 0;
	return 1;
}

OV_RESULT find_path(Node_t **path,
                    OV_UINT *pathLength,
                    Node_t* proot,
                    Node_t* ptarget) {
  OV_UINT numberOfNodes = 1;
  Node_t **explored = Ov_HeapMalloc(sizeof(Node_t*) * numberOfNodes);
  Node_t **frontier = explored;
  Node_t **endOfNodes = explored + 1;

  // root
  explored[0] = proot;

  while (endOfNodes != frontier) {
    // pick
    Node_t **current = frontier;
    frontier++;

    // explored
    if (is_same(*current, ptarget)) {
    	ov_logfile_info("found path");
    	*path = ov_memstack_alloc((*current)->depth*sizeof(Node_t));

    	OV_INT i = (*current)->depth-1;
			for (i; i >=0; i--) {
				(*path)[i] = (**current);
				current = &((*current)->pparent);
			}
//      *path = ov_memstack_alloc((current->depth) *
//                                sizeof(OV_INSTPTR_smscrmlogistic_RollerTable));
//      for (OV_UINT i = current->depth - 1; i > 0; i--) {
//        (*path)[i] = current->self;
//        ;
//        current = current->pparent;
//      }
      // free
      Ov_HeapFree(explored);
      return 0;
    }
    // add
    Node_t* children = NULL;
    OV_UINT numberOfChildren = 0;
		get_children(*current, &children, &numberOfChildren);
		numberOfNodes += numberOfChildren;
		Ov_HeapRealloc(explored, numberOfNodes * sizeof(Node_t*));
		for (OV_UINT i = 0; i < numberOfChildren; ++i) {
			explored[numberOfNodes-numberOfChildren+i] = &children[i];
			endOfNodes+=numberOfChildren;
		}
  }

  // free
  Ov_HeapFree(explored);
  return 0;
}

OV_RESULT OV_INSTPTR_graphSearch_execute(OV_INSTPTR_graphSearch_bfs pinst) {
  OV_RESULT result = OV_ERR_OK;


  OV_UINT solLength = 0;
  OV_INSTPTR_ov_object *solution = NULL;

  OV_INSTPTR_ov_object *recipes = NULL;

  OV_INSTPTR_ov_object ptop =
      ov_path_getobjectpointer(pinst->v_topologie, 2);

  OV_STRING pathStr = NULL;
  ov_string_print(&pathStr, "%s/%s", pinst->v_topologie, pinst->v_start);
  OV_INSTPTR_ov_object proot =
      ov_path_getobjectpointer(pathStr, 2);

  // get recipes
  OV_UINT numberOfStations = 1 + pinst->v_recipe.veclen;
  recipes = Ov_HeapMalloc(numberOfStations *
                          sizeof(OV_INSTPTR_ov_object));
  recipes[0] = proot;
  for (OV_UINT i = 0; i < pinst->v_recipe.veclen; ++i) {
  ov_string_print(&pathStr, "%s/%s", pinst->v_topologie, pinst->v_recipe.value[i]);
    recipes[i+1] = ov_path_getobjectpointer(pathStr, 2);
  }

  OV_UINT pathLength = 0;
  for (OV_UINT i = 0; i < numberOfStations - 1; ++i) {
    OV_INSTPTR_ov_object *path = NULL;
    OV_UINT numOfStats = 0;
    Node_t from = {
    	.self = recipes[i],
			.pparent = NULL,
			.depth = 1,
			.type = ROLLER
    };
    Node_t to	=	{
    	.self = recipes[i+1],
    };

    //list
    list_t* list =  constructList(sizeof(Node_t));
    list->printNode = printNode;
    insertLast(list, &from);
    insertLast(list, &to);
    displayForward(list);

    result = find_path(&path, &numOfStats, &from, &to);
    if (Ov_Fail(result)) {
      ov_logfile_error("no path");
      return result;
    }
    pathLength += numOfStats;
    Ov_HeapRealloc(solution, solLength + numOfStats - 1);
    memccpy(solution + solLength, path, 1000,
            (numOfStats - 1) * sizeof(OV_INSTPTR_smscrmlogistic_RollerTable));
  }
  Ov_SetDynamicVectorLength(&pinst->v_path, pathLength, STRING);
  for (OV_UINT i = 0; i < pathLength; ++i) {
    ov_string_setvalue(&pinst->v_path.value[i], solution[i]->v_identifier);
  }
  return result;
}

OV_DLLFNCEXPORT OV_RESULT
graphSearch_bfs_EN_set(OV_INSTPTR_graphSearch_bfs pobj, const OV_UINT value) {
  pobj->v_EN = value;
  switch (value) {
  case 1:
    OV_INSTPTR_graphSearch_execute(pobj);
    break;
  case 3:
    Ov_SetDynamicVectorLength(&pobj->v_path, 0, STRING);
    pobj->v_result = 0;
    break;
  default:
    break;
  }
  pobj->v_EN = 0;
  return OV_ERR_OK;
}

OV_DLLFNCEXPORT void graphSearch_bfs_typemethod(OV_INSTPTR_fb_functionblock pfb,
                                                OV_TIME *pltc) {
  /*
   *   local variables
   */
  OV_INSTPTR_graphSearch_bfs pinst = Ov_StaticPtrCast(graphSearch_bfs, pfb);
  OV_RESULT result = OV_ERR_OK;
  result = OV_INSTPTR_graphSearch_execute(pinst);

  return;
}
