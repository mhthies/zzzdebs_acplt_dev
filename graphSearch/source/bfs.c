/******************************************************************************
 *
 *   FILE
 *   ----
 *   bfs.c
 *
 *   History
 *   -------
 *   2018-05-18   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/

#ifndef OV_COMPILE_LIBRARY_graphSearch
#define OV_COMPILE_LIBRARY_graphSearch
#endif

#include <string.h>
#include <search.h>

#include "list.h"
#include "graphSearch.h"
#include "SMSTopologie.h"
#include "libov/ov_macros.h"
#include "libov/ov_path.h"
#include "libov/ov_result.h"
#include "libov/ov_debug.h"

#include "smscrmlogistic.h"


enum Level { ROLLERPOS, LEVEL0, LEVEL1 };
enum Direction { UP, RIGHT, DOWN, LEFT, MAXCHILDNUM };
const OV_STRING dirToStr[MAXCHILDNUM] = {[UP]="up", [RIGHT] = "right", [DOWN]="down", [LEFT] = "left"};

enum Nodetype { ROLLER, SCHIEBER };


typedef struct Node {
  OV_INSTPTR_ov_object self;
  enum Nodetype type;
  enum Level position;

  struct Node *pparent;
  enum Direction parentdirection;

  OV_INT depth;
} Data_t;

Data_t* constructData(){
	Data_t* data = ov_memstack_alloc(sizeof(Data_t));
	data->type = ROLLER;
	data->pparent = NULL;
	data->self = NULL;
	data->position = LEVEL0;
	data->parentdirection = UP;
	data->depth = 1;
	return data;
}

Data_t* copyData(Data_t* data){
	if(!data)
		return NULL;
	Data_t* d = constructData();
	*d = *data;
	return d;
}

void printNode(struct listNode* node){
	ov_logfile_info("%d, %d, %d, %s", ((Data_t*)node->data)->type,
	((Data_t*)node->data)->parentdirection,
	((Data_t*)node->data)->position,
	((Data_t*)node->data)->self->v_identifier);
}

int compareNodes(Data_t* d1, Data_t* d2){
	return !is_same(d1, d2);
}



OV_RESULT get_children(list_t* children, Data_t *parent) {
  OV_INSTPTR_SMSTopologie_Rollgang pparentRG = NULL;
  OV_INSTPTR_SMSTopologie_Schieber pparentS = NULL;


  switch (parent->type) {
  case ROLLER:
    pparentRG = Ov_StaticPtrCast(SMSTopologie_Rollgang, parent->self);
    break;
  case SCHIEBER:
    pparentS = Ov_StaticPtrCast(SMSTopologie_Schieber, parent->self);
    break;
  default:
    return 1;
  }
  // check validity
  //TODO:

  for (OV_UINT dir = 0; dir < MAXCHILDNUM; ++dir) {
  	Data_t *childNode = ov_memstack_alloc(sizeof(Data_t));
    childNode->depth = parent->depth + 1;
    childNode->parentdirection = dir;
    childNode->position = ROLLERPOS;
    childNode->pparent = parent;
    childNode->self = NULL;

    switch (parent->type) {
    case ROLLER:
      pparentRG = Ov_StaticPtrCast(SMSTopologie_Rollgang, parent->self);
      switch (dir) {
      case RIGHT:
        // if roller
        childNode->type = ROLLER;
        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetParent(SMSTopologie_RG, pparentRG));
        if (childNode->self)
          break;
        // if schieber
        childNode->type = SCHIEBER;

        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetParent(SMSTopologie_SchieberUntenR, pparentRG));
        childNode->position = LEVEL0;
        if (childNode->self)
          break;
        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetParent(SMSTopologie_SchieberObenR, pparentRG));
        childNode->position = LEVEL1;
        if (childNode->self)
          break;
        break;
      case LEFT:
        childNode->type = ROLLER;
        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetChild(SMSTopologie_RG, pparentRG));
        if (childNode->self)
          break;
        // if schieber
        childNode->type = SCHIEBER;

        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetParent(SMSTopologie_SchieberUntenL, pparentRG));
        childNode->position = LEVEL0;
        if (childNode->self)
          break;
        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetParent(SMSTopologie_SchieberObenL, pparentRG));
        childNode->position = LEVEL1;
        if (childNode->self)
          break;
        break;
      }
      break;

    case SCHIEBER:
      pparentS = Ov_StaticPtrCast(SMSTopologie_Schieber, parent->self);
      childNode->type = ROLLER;
      switch (parent->position) {
      case LEVEL0:
        switch (dir) {
        case UP:
          childNode->self = parent->self;
          childNode->type = SCHIEBER;
          childNode->position = LEVEL1;
          break;
        case RIGHT:
          childNode->self = Ov_StaticPtrCast(
              ov_object, Ov_GetChild(SMSTopologie_SchieberUntenL, pparentS));
          break;
        case DOWN:
          break;
        case LEFT:
          childNode->self = Ov_StaticPtrCast(
              ov_object, Ov_GetChild(SMSTopologie_SchieberUntenR, pparentS));
          break;
        }
        break;
      case LEVEL1:
        switch (dir) {
        case UP:
          break;
        case RIGHT:
          childNode->self = Ov_StaticPtrCast(
              ov_object, Ov_GetChild(SMSTopologie_SchieberObenL, pparentS));
          break;
        case DOWN:
          childNode->self = parent->self;
          childNode->type = SCHIEBER;
          childNode->position = LEVEL0;
          break;
        case LEFT:
          childNode->self = Ov_StaticPtrCast(
              ov_object, Ov_GetChild(SMSTopologie_SchieberObenR, pparentS));
          break;
        }
        break;
      }
      break;
    }
    // adding child if ok
    if (childNode->self) {
    	insertFirst(children, childNode);
    }
  }
  return 0;
}

OV_INT is_same(Data_t* r1, Data_t* r2){
	if(r1->self!=r2->self)
		return 0;
	if(r1->type != r2->type)
		return 0;
	if(r1->type==SCHIEBER)
		if(r1->position!=r2->position)
			return 0;
	return 1;
}

OV_RESULT find_path(list_t* path,
                    Data_t* proot,
                    Data_t* ptarget) {

  list_t *explored = constructList(sizeof(Data_t));
  explored->compare = compareNodes;
  explored->printNode = printNode;

  insertFirst(explored, proot);

  listNode_t *frontier = explored->head;

  while (frontier) {
    // explored
    if (is_same(frontier->data, ptarget)) {
    	ov_logfile_info("found path");

			Data_t* currentNodeData = copyData(frontier->data);
			while(currentNodeData){
				insertFirst(path, currentNodeData);
				currentNodeData = copyData(currentNodeData->pparent);
			}
      // free
      destructList(explored);
      return 0;
    }
    // add
    list_t* children = constructList(sizeof(Data_t));
    children->compare = compareNodes;
		get_children(children, frontier->data);
		listNode_t * child = NULL;
		listIterate(children, child){
			if(!listFind(explored, child->data)){
				insertLast(explored, copyData(child->data));
			}
			listPrint(explored);
		}
		destructList(children);

		//next
    frontier = frontier->next;
  }

  //free
  destructList(explored);
  return 0;
}

OV_RESULT OV_INSTPTR_graphSearch_execute(OV_INSTPTR_graphSearch_bfs pinst) {
  OV_RESULT result = OV_ERR_OK;


  OV_UINT solLength = 0;
  OV_INSTPTR_ov_object *solution = NULL;

  OV_INSTPTR_ov_object *recipes = NULL;

  OV_INSTPTR_ov_object ptop =
      ov_path_getobjectpointer(pinst->v_topologie, 2);

  OV_STRING pathStr = NULL;
  ov_string_print(&pathStr, "%s/%s", pinst->v_topologie, pinst->v_start);
  OV_INSTPTR_ov_object proot =
      ov_path_getobjectpointer(pathStr, 2);

  // get recipes
  OV_UINT numberOfStations = 1 + pinst->v_recipe.veclen;
  recipes = Ov_HeapMalloc(numberOfStations *
                          sizeof(OV_INSTPTR_ov_object));
  recipes[0] = proot;
  for (OV_UINT i = 0; i < pinst->v_recipe.veclen; ++i) {
  ov_string_print(&pathStr, "%s/%s", pinst->v_topologie, pinst->v_recipe.value[i]);
    recipes[i+1] = ov_path_getobjectpointer(pathStr, 2);
  }

  OV_UINT pathLengthSum = 0;
  for (OV_UINT i = 0; i < numberOfStations - 1; ++i) {
    Data_t from = {
    	.self = recipes[i],
			.pparent = NULL,
			.depth = 1,
			.type = ROLLER
    };
    Data_t to	=	{
    	.self = recipes[i+1],
    };

    //list
    list_t* path =  constructList(sizeof(Data_t));
    path->printNode = printNode;
    result = find_path(path, &from, &to);
    listPrint(path);
    if (Ov_Fail(result)) {
      ov_logfile_error("no path");
      return result;
    }
    //expanding arrays
    OV_UINT pathLength = listLength(path);
    pathLengthSum += pathLength-1;
    Ov_SetDynamicVectorLength(&pinst->v_pathNode, pathLengthSum, STRING);
    Ov_SetDynamicVectorLength(&pinst->v_pathDir, pathLengthSum, STRING);

    //printing
    listNode_t* element = NULL;
    OV_STRING* currentNode = (pinst->v_pathNode.value) +(pathLengthSum-pathLength+1);
    OV_STRING* currentDir	= (pinst->v_pathDir.value) + (pathLengthSum-pathLength+1);
    listIterate(path, element){
    	if(!element->prev){
    		continue;
    	}
    	ov_string_setvalue(currentNode, ((Data_t*)element->data)->self->v_identifier);
    	ov_string_setvalue(currentDir, dirToStr[((Data_t*)element->data)->parentdirection]);
    	currentNode++;
    	currentDir++;
    }
  }
  return result;
}

OV_DLLFNCEXPORT OV_RESULT
graphSearch_bfs_EN_set(OV_INSTPTR_graphSearch_bfs pobj, const OV_UINT value) {
  pobj->v_EN = value;
  switch (value) {
  case 1:
    OV_INSTPTR_graphSearch_execute(pobj);
    break;
  case 3:
    Ov_SetDynamicVectorLength(&pobj->v_pathNode, 0, STRING);
    Ov_SetDynamicVectorLength(&pobj->v_pathDir, 0, STRING);
    pobj->v_result = 0;
    break;
  default:
    break;
  }
  pobj->v_EN = 0;
  return OV_ERR_OK;
}

OV_DLLFNCEXPORT void graphSearch_bfs_typemethod(OV_INSTPTR_fb_functionblock pfb,
                                                OV_TIME *pltc) {
  /*
   *   local variables
   */
  OV_INSTPTR_graphSearch_bfs pinst = Ov_StaticPtrCast(graphSearch_bfs, pfb);
  OV_RESULT result = OV_ERR_OK;
  result = OV_INSTPTR_graphSearch_execute(pinst);

  return;
}
