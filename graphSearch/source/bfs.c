/******************************************************************************
 *
 *   FILE
 *   ----
 *   bfs.c
 *
 *   History
 *   -------
 *   2018-05-18   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/
#define OV_DEBUG

#ifndef OV_COMPILE_LIBRARY_graphSearch
#define OV_COMPILE_LIBRARY_graphSearch
#endif

#include <string.h>
#include <search.h>

#include "list.h"
#include "graphSearch.h"
#include "SMSTopologie.h"
#include "libov/ov_macros.h"
#include "libov/ov_path.h"
#include "libov/ov_result.h"
#include "libov/ov_debug.h"

#include "smscrmlogistic.h"


enum Direction { UP, RIGHT, DOWN, LEFT, MAXCHILDNUM};
const OV_STRING dirToStr[MAXCHILDNUM] = {[UP]="up", [RIGHT] = "right", [DOWN]="down", [LEFT] = "left"};

enum Datatype { ROLLER, SCHIEBER };
enum Level { NEUTRAL, LEVEL0, LEVEL1 };

/* data type for list */
typedef struct Data_s {
  OV_INSTPTR_ov_object self;
  enum Datatype type;
  enum Level position;

  struct Data_s *pparent;
  enum Direction parentdirection;

  OV_INT depth;
} Data_t;

Data_t* constructData(){
	Data_t* data = ov_memstack_alloc(sizeof(Data_t));
	data->self = NULL;
	data->type = ROLLER;
	data->pparent = NULL;
	data->position = LEVEL0;
	data->parentdirection = UP;
	data->depth = 1;
	return data;
}

void init(Data_t* d, OV_INSTPTR_ov_object obj, enum Datatype type){
	Ov_AbortIf(!d);
	d->self = obj;
	d->type = type;
	d->pparent = NULL;
	d->position = NEUTRAL;
	d->parentdirection = UP;
	d->depth = 1;
}

//Data_t* copyData(Data_t* data){
//	if(!data)
//		return NULL;
//	Data_t* d = constructData();
//	*d = *data;
//	return d;
//}

/* compares 2 data as topology */
OV_BOOL is_same(Data_t* r1, Data_t* r2){
	if(r1->self!=r2->self)
		return 0;
	if(r1->type != r2->type)
		return 0;
	if(r1->type==SCHIEBER){
		if(r1->position==NEUTRAL || r2->position==NEUTRAL)
			return 1;
		else if(r1->position!=r2->position)
			return 0;
	}
	return 1;
}

/* how to print data in listPrint */
void printData(struct listNode* node){
	printf("(%d, %s, %d, %s)", ((Data_t*)node->data)->type,
	dirToStr[((Data_t*)node->data)->parentdirection],
	((Data_t*)node->data)->position,
	((Data_t*)node->data)->self->v_identifier);
}

/* get children of parent for bfs and adds it to children*/
OV_RESULT get_children(list_t* children, Data_t *parent) {
  OV_INSTPTR_SMSTopologie_Rollgang pparentRG = NULL;
  OV_INSTPTR_SMSTopologie_Schieber pparentS = NULL;


  switch (parent->type) {
  case ROLLER:
    pparentRG = Ov_StaticPtrCast(SMSTopologie_Rollgang, parent->self);
    break;
  case SCHIEBER:
    pparentS = Ov_StaticPtrCast(SMSTopologie_Schieber, parent->self);
    break;
  default:
    return 1;
  }
  // check validity
  //TODO:

  for (OV_UINT dir = 0; dir < MAXCHILDNUM; ++dir) {
  	Data_t *childNode = ov_memstack_alloc(sizeof(Data_t));
    childNode->depth = parent->depth + 1;
    childNode->parentdirection = dir;
    childNode->position = NEUTRAL;
    childNode->pparent = parent;
    childNode->self = NULL;

    switch (parent->type) {
    case ROLLER:
      pparentRG = Ov_StaticPtrCast(SMSTopologie_Rollgang, parent->self);
      switch (dir) {
      case RIGHT:
        // if roller
        childNode->type = ROLLER;
        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetParent(SMSTopologie_RG, pparentRG));
        if (childNode->self)
          break;
        // if schieber
        childNode->type = SCHIEBER;

        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetParent(SMSTopologie_SchieberUntenR, pparentRG));
        childNode->position = LEVEL0;
        if (childNode->self)
          break;
        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetParent(SMSTopologie_SchieberObenR, pparentRG));
        childNode->position = LEVEL1;
        if (childNode->self)
          break;
        break;
      case LEFT:
        childNode->type = ROLLER;
        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetChild(SMSTopologie_RG, pparentRG));
        if (childNode->self)
          break;
        // if schieber
        childNode->type = SCHIEBER;

        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetParent(SMSTopologie_SchieberUntenL, pparentRG));
        childNode->position = LEVEL0;
        if (childNode->self)
          break;
        childNode->self = Ov_StaticPtrCast(
            ov_object, Ov_GetParent(SMSTopologie_SchieberObenL, pparentRG));
        childNode->position = LEVEL1;
        if (childNode->self)
          break;
        break;
      }
      break;

    case SCHIEBER:
      pparentS = Ov_StaticPtrCast(SMSTopologie_Schieber, parent->self);
      childNode->type = ROLLER;
      switch (parent->position) {
      case NEUTRAL:
      	//TODO: Find a way to add children reasonable
      	switch (dir) {
        case UP:
        	*childNode = *parent;
        	childNode->position = LEVEL1;
          break;
        case RIGHT:
          break;
        case DOWN:
        	*childNode = *parent;
        	childNode->position = LEVEL0;
          break;
        case LEFT:
          break;
        }
        break;
      case LEVEL0:
        switch (dir) {
        case UP:
          childNode->self = parent->self;
          childNode->type = SCHIEBER;
          childNode->position = LEVEL1;
          break;
        case RIGHT:
          childNode->self = Ov_StaticPtrCast(
              ov_object, Ov_GetChild(SMSTopologie_SchieberUntenL, pparentS));
          break;
        case DOWN:
          break;
        case LEFT:
          childNode->self = Ov_StaticPtrCast(
              ov_object, Ov_GetChild(SMSTopologie_SchieberUntenR, pparentS));
          break;
        }
        break;
      case LEVEL1:
        switch (dir) {
        case UP:
          break;
        case RIGHT:
          childNode->self = Ov_StaticPtrCast(
              ov_object, Ov_GetChild(SMSTopologie_SchieberObenL, pparentS));
          break;
        case DOWN:
          childNode->self = parent->self;
          childNode->type = SCHIEBER;
          childNode->position = LEVEL0;
          break;
        case LEFT:
          childNode->self = Ov_StaticPtrCast(
              ov_object, Ov_GetChild(SMSTopologie_SchieberObenR, pparentS));
          break;
        }
        break;
      }
      break;
    }
    // adding child if ok
    if (childNode->self) {
    	insertFirst(children, childNode);
    }
  }
  return 0;
}

/* execute BFS */
OV_RESULT BFS(list_t* path,
                    Data_t* proot,
                    Data_t* ptarget) {

	Ov_AbortIf(proot->pparent);
	Ov_AbortIf(proot->depth!=1);

  list_t *explored = constructList(sizeof(Data_t));
  explored->is_same = &is_same;
  explored->printNode = &printData;

  if(proot->type==SCHIEBER && proot->position==NEUTRAL){
  	Data_t* schieberL1 = constructData();
  	*schieberL1 = *proot;
  	schieberL1->position = LEVEL1;
  	insertFirst(explored, schieberL1);

  	Data_t* schieberL0 = constructData();
  	*schieberL0 = *proot;
  	schieberL0->position = LEVEL0;
  	insertFirst(explored, schieberL0);
  } else
  	insertFirst(explored, proot);

  listNode_t *frontier = explored->head;

  while (frontier) {
    // explored
    if (is_same(frontier->data, ptarget)) {
//    	ov_logfile_info("found path");

			Data_t* currentNodeData = frontier->data;
			while(currentNodeData) {
				insertFirst(path, currentNodeData);
				currentNodeData = currentNodeData->pparent;
			};
//			Data_t* currentNodeData = copyData(frontier->data);
//			while(currentNodeData){
//				insertFirst(path, currentNodeData);
//				currentNodeData = copyData(currentNodeData->pparent);
//			}
      // free
      destructList(explored);
      return 0;
    }
    // add
    list_t* children = constructList(sizeof(Data_t));
    children->is_same = &is_same;
		get_children(children, frontier->data);
		listNode_t * child = NULL;
		listIterate(children, child){
			if(!listFind(explored, child->data)){
				insertLast(explored, child->data);
			}
//			listPrint(explored);
		}
		destructList(children);

		//next
    frontier = frontier->next;
  }

  //free
  destructList(explored);
  return 1;
}

OV_RESULT OV_INSTPTR_graphSearch_execute(OV_INSTPTR_graphSearch_bfs pinst) {
  //variables
	OV_RESULT result = OV_ERR_OK;
  OV_INSTPTR_ov_object *recipes = NULL;

  //param check
  if(!ov_path_getobjectpointer(pinst->v_topologie, 2)){
  	ov_logfile_error("topology could not be found");
  	return OV_ERR_BADPARAM;
  }

  //get start
  OV_STRING pathStr = NULL;
  ov_string_print(&pathStr, "%s/%s", pinst->v_topologie, pinst->v_start);
  OV_INSTPTR_ov_object proot =
      ov_path_getobjectpointer(pathStr, 2);
  //param check
  if(!proot){
  	ov_logfile_error("start object could not be found");
  	return OV_ERR_BADPARAM;
  }

  // get recipes
  OV_UINT numberOfStations = 1 + pinst->v_recipe.veclen;
  recipes = Ov_HeapMalloc(numberOfStations *
                          sizeof(OV_INSTPTR_ov_object));
  recipes[0] = proot;
  for (OV_UINT i = 0; i < pinst->v_recipe.veclen; ++i) {
  ov_string_print(&pathStr, "%s/%s", pinst->v_topologie, pinst->v_recipe.value[i]);
    recipes[i+1] = ov_path_getobjectpointer(pathStr, 2);

  	//param check
    if(!recipes[i+1]){
    	ov_logfile_error("recipe[%d] object could not be found", i);
    	return OV_ERR_BADPARAM;
    }
  }

  //bfs
  OV_UINT pathLengthSum = 0;
  Data_t from;
  if(Ov_CanCastTo(SMSTopologie_Rollgang, recipes[0]))
  	init(&from, recipes[0], ROLLER);
  else if(Ov_CanCastTo(SMSTopologie_Schieber, recipes[0]))
  	init(&from, recipes[0], SCHIEBER);
  else{
  	return OV_ERR_BADOBJTYPE;
  }

  for (OV_UINT i = 1; i < numberOfStations; ++i) {
    Data_t to;
    if(Ov_CanCastTo(SMSTopologie_Rollgang, recipes[i]))
    	init(&to, recipes[i], ROLLER);
    else if(Ov_CanCastTo(SMSTopologie_Schieber, recipes[i]))
    	init(&to, recipes[i], SCHIEBER);
    else{
    	return OV_ERR_BADOBJTYPE;
    }
    //list
    list_t* path =  constructList(sizeof(Data_t));
    path->printNode = &printData;
    result = BFS(path, &from, &to);
//    listPrint(path);
    if (Ov_Fail(result)) {
      ov_logfile_error("No path found from %s to %s", from.self->v_identifier, to.self->v_identifier);
      return result;
    }
    //setting next from
    from = *(Data_t*)(path->last->data);
    from.pparent = NULL;
    from.depth = 1;

    //expanding arrays
    OV_UINT pathLength = listLength(path);
    pathLengthSum += pathLength-1;
    Ov_SetDynamicVectorLength(&pinst->v_pathNode, pathLengthSum, STRING);
    Ov_SetDynamicVectorLength(&pinst->v_pathDir, pathLengthSum, STRING);

    //printing
    listNode_t* element = NULL;
    OV_STRING* currentNode = (pinst->v_pathNode.value) +(pathLengthSum-(pathLength-1));
    OV_STRING* currentDir	= (pinst->v_pathDir.value) + (pathLengthSum-(pathLength-1));
    listIterate(path, element){
    	if(!element->prev){
    		continue;
    	}
    	ov_string_setvalue(currentNode, ((Data_t*)element->data)->self->v_identifier);
    	ov_string_setvalue(currentDir, dirToStr[((Data_t*)element->data)->parentdirection]);
    	currentNode++;
    	currentDir++;
    }
    destructList(path);
  }
  return result;
}

OV_DLLFNCEXPORT OV_RESULT
graphSearch_bfs_EN_set(OV_INSTPTR_graphSearch_bfs pobj, const OV_UINT value) {
  pobj->v_EN = value;
  OV_TIME pltc;

  switch (value) {
  case 1:
  	ov_time_gettime(&pltc);
    graphSearch_bfs_typemethod(Ov_StaticPtrCast(fb_functionblock, pobj), &pltc);
    break;
  case 3:
    Ov_SetDynamicVectorLength(&pobj->v_pathNode, 0, STRING);
    Ov_SetDynamicVectorLength(&pobj->v_pathDir, 0, STRING);
    pobj->v_result = 0;
    break;
  default:
    break;
  }
  pobj->v_EN = 0;
  return OV_ERR_OK;
}

OV_DLLFNCEXPORT void graphSearch_bfs_typemethod(OV_INSTPTR_fb_functionblock pfb,
                                                OV_TIME *pltc) {
  /*
   *   local variables
   */
  OV_INSTPTR_graphSearch_bfs pinst = Ov_StaticPtrCast(graphSearch_bfs, pfb);
  OV_RESULT result = OV_ERR_OK;
  result = OV_INSTPTR_graphSearch_execute(pinst);
  switch(result){
  case OV_ERR_OK:
  	ov_logfile_info("bfs: done");
  	pinst->v_result = result;
  	break;
  case OV_ERR_BADPARAM:
  	ov_logfile_error("bfs: bad param");
  	pinst->v_result = result;
  	break;
  default:
  	ov_logfile_error("bfs: failed \n error: %s", ov_result_getresulttext(result));
  	pinst->v_result = 1;
  }

  return;
}
